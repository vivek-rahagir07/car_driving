<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Driving</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            /* Prevent scrolling and pull-to-refresh on mobile */
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        .game-button {
            display: inline-block;
            background-image: linear-gradient(to right, #3b82f6, #2563eb);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.2s ease-in-out;
            border: none;
            cursor: pointer;
            user-select: none;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-image: linear-gradient(to right, #2563eb, #3b82f6);
        }

        .control-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.25rem;
            color: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
            user-select: none;
            transition: all 0.1s ease;
        }

        /* Class to be added on touch */
        .control-button.active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        #accelButton {
            background-image: linear-gradient(to top, #16a34a, #22c55e);
        }

        #brakeButton {
            background-image: linear-gradient(to top, #dc2626, #ef4444);
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .pulse-animation {
            animation: pulse 0.5s ease-in-out;
        }

        /* Mobile Controls Overlay */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 180px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 20;
        }

        .control-section {
            display: flex;
            align-items: flex-end;
            pointer-events: auto;
        }

        #steeringContainer {
            width: 160px;
            height: 160px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #steeringWheel {
            width: 100%;
            height: 100%;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='48' fill='none' stroke='%23333' stroke-width='4'/%3E%3Ccircle cx='50' cy='50' r='44' fill='%231a1a1a' stroke='%23555' stroke-width='2'/%3E%3Cpath d='M50 50 L50 6' stroke='%23333' stroke-width='8'/%3E%3Cpath d='M50 50 L10 70' stroke='%23333' stroke-width='8'/%3E%3Cpath d='M50 50 L90 70' stroke='%23333' stroke-width='8'/%3E%3Ccircle cx='50' cy='50' r='10' fill='%23333'/%3E%3Ccircle cx='50' cy='50' r='4' fill='%23555'/%3E%3Cpath d='M48 6 L52 6' stroke='red' stroke-width='4'/%3E%3C/svg%3E") no-repeat center center;
            background-size: contain;
            transition: transform 0.1s ease-out;
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.5));
        }

        .pedal-group {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .pedal {
            position: relative;
            transition: transform 0.1s;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.4));
        }

        .pedal:active,
        .pedal.active {
            transform: scale(0.95) translateY(2px);
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.4));
        }

        #btnBrake {
            width: 80px;
            height: 60px;
            background: linear-gradient(180deg, #555, #333);
            border-radius: 8px;
            border: 2px solid #777;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #btnBrake::after {
            content: '';
            width: 70%;
            height: 4px;
            background: #222;
            box-shadow: 0 10px 0 #222, 0 20px 0 #222;
        }

        #btnGas {
            width: 60px;
            height: 120px;
            background: linear-gradient(180deg, #333, #111);
            border-radius: 8px;
            border: 2px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #btnGas::after {
            content: '';
            width: 4px;
            height: 80%;
            background: #222;
            box-shadow: 10px 0 0 #222, -10px 0 0 #222;
        }

        /* Hide specific elements on mobile if needed */
        @media (max-width: 768px) {
            .desktop-hint {
                display: none;
            }
        }
    </style>
</head>

<body class="bg-gray-900 min-h-screen flex flex-col items-center justify-center text-white p-4">

    <h1
        class="text-4xl md:text-5xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-blue-600">
        City Driving
    </h1>

    <div class="mb-2 flex gap-6 text-xl font-medium">
        <div>Score: <span id="score" class="font-bold text-yellow-300">0</span></div>
        <div>Speed: <span id="speedDisplay" class="font-bold text-cyan-300">1.0x</span></div>
        <div id="comboDisplay" class="font-bold text-green-400 hidden">Combo: <span id="comboValue">0</span>x</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Mobile Controls Overlay -->
    <div id="mobileControls" class="md:hidden">
        <div class="control-section">
            <div id="steeringContainer">
                <div id="steeringWheel"></div>
            </div>
        </div>

        <div class="control-section pedal-group">
            <div id="btnBrake" class="pedal"></div>
            <div id="btnGas" class="pedal"></div>
        </div>
    </div>

    <p class="mt-4 text-gray-400 text-sm md:text-base text-center desktop-hint">
        Keys: Left/Right or A/D (Move), Up/W (Race), Down/S (Brake)
    </p>

    <div id="gameOverModal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div
            class="bg-white text-gray-900 p-8 md:p-12 rounded-lg shadow-2xl text-center transform scale-90 transition-all">
            <h2 class="text-3xl font-bold mb-4">Game Over!</h2>
            <p class="text-xl mb-2">
                Final Score: <span id="finalScore" class="font-bold text-blue-600">0</span>
            </p>
            <p class="text-lg mb-6">
                Max Combo: <span id="finalCombo" class="font-bold text-green-600">0</span>x
            </p>
            <button id="restartButton" class="game-button">
                Play Again
            </button>
        </div>
    </div>

    <script type="module">
        // --- DOM Element Selection ---
        const canvas = document.getElementById('gameCanvas');
        const scoreEl = document.getElementById('score');
        const speedDisplayEl = document.getElementById('speedDisplay');
        const comboDisplayEl = document.getElementById('comboDisplay');
        const comboValueEl = document.getElementById('comboValue');
        const modalEl = document.getElementById('gameOverModal');
        const finalScoreEl = document.getElementById('finalScore');
        const finalComboEl = document.getElementById('finalCombo');
        const restartButton = document.getElementById('restartButton');
        const steeringContainer = document.getElementById('steeringContainer');
        const steeringWheel = document.getElementById('steeringWheel');
        const btnGas = document.getElementById('btnGas');
        const btnBrake = document.getElementById('btnBrake');

        // --- Steering Logic Variables ---
        let isDraggingWheel = false;
        let wheelInitAngle = 0;
        let wheelCurrentRotation = 0;
        let hasTriggeredTurn = false; // Prevent multiple turns in one drag without resetting

        // --- 3D Scene Variables ---
        let scene, camera, renderer;
        let playerCar, road, roadLines = [];
        let enemies = [], ambulances = [], trafficLights = [], scenery = [];
        let coins = []; // <-- ADDED

        // --- Game Constants ---
        // Moved this block *before* Game State Variables to fix initialization error
        const LANE_COUNT = 3;
        const LANE_WIDTH = 5;
        const ROAD_WIDTH = LANE_COUNT * LANE_WIDTH;
        const ROAD_LENGTH = 100;
        const CAR_BODY_WIDTH = 2.5;
        const CAR_BODY_HEIGHT = 1.0;
        const CAR_BODY_DEPTH = 4.5;
        const WHEEL_RADIUS = 0.5;
        const WHEEL_THICKNESS = 0.3;

        const PLAYER_Z_POSITION = 15;
        const SPAWN_Z_POSITION = -ROAD_LENGTH * 1.5;
        const DESPAWN_Z_POSITION = PLAYER_Z_POSITION + 20;


        // --- Game State Variables ---
        let score, gameSpeed, gameOver, animationFrameId;
        let playerLane = 1;
        let playerTargetX = 0;
        let isAccelerating = false;
        let isBraking = false;
        let combo = 0;
        let maxCombo = 0;
        let comboTimer = 0;
        let particles = [];

        let lastSpawnZ = SPAWN_Z_POSITION; // To avoid object pileups
        let lastCoinSpawnZ = SPAWN_Z_POSITION; // <-- ADDED

        // --- Color Palette ---
        const PLAYER_COLOR = 0x3b82f6;
        const ENEMY_COLORS = [0xef4444, 0xf97316, 0xeab308, 0x8b5cf6, 0xec4899, 0x10b981, 0x6b7280];
        const AMBULANCE_LIGHT_COLOR = 0xef4444;
        const GREEN_LIGHT_COLOR = 0x22c55e;
        const RED_LIGHT_COLOR = 0xef4444;
        const ROAD_COLOR = 0x34495e;
        const LINE_COLOR = 0xffffff;
        const TREE_TRUNK_COLOR = 0x845320;
        const TREE_LEAVES_COLOR = 0x22c55e;
        const BUILDING_COLORS = [0x6b7280, 0x71717a, 0x52525b];
        const STREET_LIGHT_COLOR = 0xf1c40f;
        const STREET_POLE_COLOR = 0x555555;
        const COIN_COLOR = 0xffd700; // <-- ADDED

        let CANVAS_WIDTH, CANVAS_HEIGHT;

        // --- Utility Functions ---
        function random(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function randomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        function laneToX(lane) {
            // Calculates the X coordinate for a given lane index
            return (lane - (LANE_COUNT - 1) / 2) * LANE_WIDTH;
        }

        // --- Core Game Setup ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            scene.fog = new THREE.Fog(0x2c3e50, 50, 150);

            updateCanvasSize();
            camera = new THREE.PerspectiveCamera(75, CANVAS_WIDTH / CANVAS_HEIGHT, 0.1, 1000);
            camera.position.set(0, 8, PLAYER_Z_POSITION + 7);
            camera.lookAt(0, 0, PLAYER_Z_POSITION - 10);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
            renderer.shadowMap.enabled = true;

            // --- Lighting ---
            const ambientLight = new THREE.HemisphereLight(0xaaccff, 0x444444, 0.8);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(10, 20, 0);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            scene.add(dirLight);

            // --- Road ---
            const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH * 2);
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: ROAD_COLOR,
                roughness: 0.8,
                metalness: 0.1
            });
            road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.z = -ROAD_LENGTH / 2 + PLAYER_Z_POSITION;
            road.receiveShadow = true;
            scene.add(road);

            // --- Road Lines ---
            const lineMat = new THREE.MeshStandardMaterial({ color: LINE_COLOR, roughness: 0.5 });
            const lineGeom = new THREE.PlaneGeometry(0.5, 7);
            const lineGap = 10;
            for (let i = 1; i < LANE_COUNT; i++) {
                const lineX = laneToX(i - 1) + LANE_WIDTH / 2;
                for (let z = -ROAD_LENGTH * 2; z < ROAD_LENGTH * 2; z += lineGap + 7) {
                    const line = new THREE.Mesh(lineGeom, lineMat);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(lineX, 0.01, z);
                    scene.add(line);
                    roadLines.push(line);
                }
            }

            // --- Add Event Listeners ---
            addEventListeners();

            resetGame(); // Set up initial game state
        }

        function resetGame() {
            // Stop previous loop if running
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // Reset game state variables
            score = 0;
            gameSpeed = 0.3; // <-- CHANGED
            gameOver = false;
            isAccelerating = false;
            isBraking = false;
            combo = 0;
            maxCombo = 0;
            comboTimer = 0;
            lastSpawnZ = SPAWN_Z_POSITION;
            lastCoinSpawnZ = SPAWN_Z_POSITION; // <-- ADDED

            // Clear old car if it exists
            if (playerCar) scene.remove(playerCar);

            // Clear all obstacles and scenery
            [...enemies, ...ambulances, ...trafficLights].forEach(obj => scene.remove(obj.mesh));
            scenery.forEach(obj => scene.remove(obj)); // This removes groups (trees, buildings, lights)
            coins.forEach(obj => scene.remove(obj.mesh)); // <-- ADDED
            enemies = [];
            ambulances = [];
            trafficLights = [];
            scenery = [];
            coins = []; // <-- ADDED

            // Clear particles
            particles.forEach(p => scene.remove(p));
            particles = [];

            // Create new player car
            playerCar = createCar(PLAYER_COLOR, true);
            playerLane = 1;
            playerTargetX = laneToX(playerLane);
            playerCar.position.set(playerTargetX, 0, PLAYER_Z_POSITION);
            scene.add(playerCar);

            // Reset UI
            scoreEl.textContent = score;
            speedDisplayEl.textContent = '1.0x';
            comboDisplayEl.classList.add('hidden');
            modalEl.classList.add('hidden');
            modalEl.querySelector('div').classList.remove('scale-100');
            modalEl.querySelector('div').classList.add('scale-90');

            // Start the game loop
            animate();
        }

        // --- Particle System ---
        function createParticle(position, color) {
            const geom = new THREE.SphereGeometry(0.3, 8, 8);
            const mat = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 1
            });
            const particle = new THREE.Mesh(geom, mat);
            particle.position.copy(position);

            const velocity = new THREE.Vector3(
                randomFloat(-2, 2),
                randomFloat(1, 3),
                randomFloat(-2, 2)
            );

            particle.userData.velocity = velocity;
            particle.userData.life = 1.0;

            scene.add(particle);
            particles.push(particle);
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.velocity.y -= 0.05; // Gravity
                p.userData.life -= 0.02;

                p.material.opacity = p.userData.life;
                p.material.transparent = true;

                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        // --- Object Creation ---
        // --- REVISED createCar function (Removed the duplicate) ---
        function createCar(color, isPlayer = false) {
            const car = new THREE.Group();
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const bodyMat = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.8,
                roughness: 0.2
            });

            // --- New Body Shape ---
            // Main Chassis (this will be the collision box)
            const chassisHeight = CAR_BODY_HEIGHT * 0.8;
            const chassisGeom = new THREE.BoxGeometry(CAR_BODY_WIDTH, chassisHeight, CAR_BODY_DEPTH);
            const chassis = new THREE.Mesh(chassisGeom, bodyMat);
            chassis.position.y = WHEEL_RADIUS + chassisHeight / 2;
            chassis.castShadow = true;
            chassis.receiveShadow = true;
            car.add(chassis);

            // We use the chassis for the collision box
            car.userData.box = new THREE.Box3();

            // Cabin
            const cabinHeight = CAR_BODY_HEIGHT * 0.7;
            const cabinWidth = CAR_BODY_WIDTH * 0.7;
            const cabinDepth = CAR_BODY_DEPTH * 0.35;
            const cabinGeom = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinDepth);
            const cabinMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            const cabin = new THREE.Mesh(cabinGeom, cabinMat);
            cabin.position.y = chassis.position.y + chassisHeight / 2 + cabinHeight / 2 - 0.1;
            cabin.position.z = isPlayer ? CAR_BODY_DEPTH * 0.1 : -CAR_BODY_DEPTH * 0.1; // Cabin offset
            cabin.castShadow = true;
            car.add(cabin);

            // Hood
            const hoodHeight = CAR_BODY_HEIGHT * 0.3;
            const hoodGeom = new THREE.BoxGeometry(CAR_BODY_WIDTH * 0.8, hoodHeight, CAR_BODY_DEPTH * 0.4);
            const hood = new THREE.Mesh(hoodGeom, bodyMat);
            const hoodZPos = isPlayer ? CAR_BODY_DEPTH * 0.3 : -CAR_BODY_DEPTH * 0.3;
            hood.position.set(0, chassis.position.y, hoodZPos);
            car.add(hood);


            // Player-only spoiler
            if (isPlayer) {
                const spoilerGeom = new THREE.BoxGeometry(CAR_BODY_WIDTH * 1.1, 0.2, 0.5);
                const spoiler = new THREE.Mesh(spoilerGeom, bodyMat);
                spoiler.position.set(0, chassis.position.y + chassisHeight / 2, -CAR_BODY_DEPTH / 2 - 0.25);
                car.add(spoiler);
            }

            // Wheels
            const wheelGeom = new THREE.CylinderGeometry(WHEEL_RADIUS, WHEEL_RADIUS, WHEEL_THICKNESS, 16);
            wheelGeom.rotateZ(Math.PI / 2); // Orient cylinders as wheels

            const wheelPositions = [
                new THREE.Vector3(-CAR_BODY_WIDTH / 2, WHEEL_RADIUS, CAR_BODY_DEPTH / 2 * 0.7), // Front Left
                new THREE.Vector3(CAR_BODY_WIDTH / 2, WHEEL_RADIUS, CAR_BODY_DEPTH / 2 * 0.7),  // Front Right
                new THREE.Vector3(-CAR_BODY_WIDTH / 2, WHEEL_RADIUS, -CAR_BODY_DEPTH / 2 * 0.7), // Back Left
                new THREE.Vector3(CAR_BODY_WIDTH / 2, WHEEL_RADIUS, -CAR_BODY_DEPTH / 2 * 0.7)  // Back Right
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                wheel.position.copy(pos);
                wheel.castShadow = true;
                car.add(wheel);
            });

            // Lights
            const lightGeom = new THREE.BoxGeometry(CAR_BODY_WIDTH * 0.2, CAR_BODY_HEIGHT * 0.3, 0.1);

            if (isPlayer) {
                // Taillights for player
                const taillightMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1 });
                const lightL = new THREE.Mesh(lightGeom, taillightMat);
                const lightR = new THREE.Mesh(lightGeom, taillightMat);
                lightL.position.set(-CAR_BODY_WIDTH * 0.3, chassis.position.y, -CAR_BODY_DEPTH / 2 - 0.01);
                lightR.position.set(CAR_BODY_WIDTH * 0.3, chassis.position.y, -CAR_BODY_DEPTH / 2 - 0.01);
                car.add(lightL, lightR);
            } else {
                // Headlights for enemies
                const headlightMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 1 });
                const lightL = new THREE.Mesh(lightGeom, headlightMat);
                const lightR = new THREE.Mesh(lightGeom, headlightMat);
                lightL.position.set(-CAR_BODY_WIDTH * 0.3, chassis.position.y, CAR_BODY_DEPTH / 2 + 0.01);
                lightR.position.set(CAR_BODY_WIDTH * 0.3, chassis.position.y, CAR_BODY_DEPTH / 2 + 0.01);
                car.add(lightL, lightR);
            }

            // Set collision box from the chassis
            car.userData.box.setFromObject(chassis);

            return car;
        }


        function createAmbulance() {
            const ambu = createCar(0xffffff); // White body

            // Add flashing light on top
            const lightGeom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const lightMat = new THREE.MeshStandardMaterial({
                color: AMBULANCE_LIGHT_COLOR,
                emissive: AMBULANCE_LIGHT_COLOR,
                emissiveIntensity: 2
            });
            const light = new THREE.Mesh(lightGeom, lightMat);
            // Position it on top of the cabin
            // --- UPDATED Y position based on new car model ---
            light.position.set(0, (WHEEL_RADIUS + CAR_BODY_HEIGHT * 0.8) + (CAR_BODY_HEIGHT * 0.7) - 0.1, 0);
            ambu.add(light);

            ambu.userData.flashingLight = light;
            ambu.userData.isAmbulance = true;

            return ambu;
        }

        function createTrafficLight(type) {
            const lightGroup = new THREE.Group();
            const color = (type === 'GREEN') ? GREEN_LIGHT_COLOR : RED_LIGHT_COLOR;

            const lightGeom = new THREE.CylinderGeometry(LANE_WIDTH * 0.4, LANE_WIDTH * 0.4, 1.5, 16);
            const lightMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 2 });
            const light = new THREE.Mesh(lightGeom, lightMat);

            light.position.y = 4;
            light.castShadow = true;
            lightGroup.add(light);

            lightGroup.userData.box = new THREE.Box3().setFromObject(light);
            lightGroup.userData.type = type;
            lightGroup.userData.isLight = true;

            return lightGroup;
        }

        // --- NEW: Creates a coin ---
        function createCoin() {
            const coinGeom = new THREE.CylinderGeometry(0.7, 0.7, 0.2, 16);
            const coinMat = new THREE.MeshStandardMaterial({
                color: COIN_COLOR,
                metalness: 0.8,
                roughness: 0.3,
                emissive: 0xaa8800,
                emissiveIntensity: 0.5
            });
            const coin = new THREE.Mesh(coinGeom, coinMat);
            coin.rotation.x = Math.PI / 2; // Lay flat

            // The coin itself is the collision box
            coin.userData.box = new THREE.Box3();

            const coinGroup = new THREE.Group();
            coinGroup.add(coin);
            // We use the *group* to store the box for consistency
            coinGroup.userData.box = new THREE.Box3().setFromObject(coin);

            return coinGroup;
        }

        function createTree() {
            const tree = new THREE.Group();

            const trunkHeight = randomFloat(4, 8);
            const trunkGeom = new THREE.CylinderGeometry(0.5, 0.7, trunkHeight, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: TREE_TRUNK_COLOR, roughness: 0.9 });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            tree.add(trunk);

            const leavesHeight = randomFloat(5, 10);
            const leavesGeom = new THREE.ConeGeometry(randomFloat(2, 4), leavesHeight, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: TREE_LEAVES_COLOR, roughness: 0.9 });
            const leaves = new THREE.Mesh(leavesGeom, leavesMat);
            leaves.position.y = trunkHeight + leavesHeight / 2 - 1;
            leaves.castShadow = true;
            tree.add(leaves);

            return tree;
        }

        function createBuilding() {
            const height = randomFloat(10, 40);
            const width = randomFloat(8, 15);
            const depth = randomFloat(8, 15);
            const geom = new THREE.BoxGeometry(width, height, depth);
            const color = BUILDING_COLORS[random(0, BUILDING_COLORS.length - 1)];
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
            const building = new THREE.Mesh(geom, mat);
            building.position.y = height / 2;
            building.castShadow = true;
            building.receiveShadow = true;
            return building;
        }

        /** --- NEW: Creates a street light --- */
        function createStreetLight() {
            const lightGroup = new THREE.Group();
            const poleMat = new THREE.MeshStandardMaterial({ color: STREET_POLE_COLOR, roughness: 0.7 });

            // Pole
            const poleHeight = 10;
            const poleGeom = new THREE.CylinderGeometry(0.2, 0.2, poleHeight, 8);
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.y = poleHeight / 2;
            pole.castShadow = true;
            lightGroup.add(pole);

            // Arm
            const armGeom = new THREE.BoxGeometry(3, 0.2, 0.2);
            const arm = new THREE.Mesh(armGeom, poleMat);
            arm.position.set(1.5, poleHeight - 0.5, 0);
            arm.castShadow = true;
            lightGroup.add(arm);

            // Lamp Head
            const lampGeom = new THREE.BoxGeometry(0.6, 0.4, 0.6);
            const lampMat = new THREE.MeshStandardMaterial({ color: STREET_LIGHT_COLOR, emissive: STREET_LIGHT_COLOR, emissiveIntensity: 2 });
            const lamp = new THREE.Mesh(lampGeom, lampMat);
            lamp.position.set(2.8, poleHeight - 0.5, 0);
            lightGroup.add(lamp);

            // The actual light source
            const spotLight = new THREE.SpotLight(0xfffadd, 2.0, 30, Math.PI * 0.4, 0.5);
            spotLight.position.set(2.8, poleHeight - 0.8, 0);
            spotLight.target.position.set(2.8, 0, 0);
            spotLight.castShadow = true;

            // Add target to the group so it moves with the light
            lightGroup.add(spotLight);
            lightGroup.add(spotLight.target);

            return lightGroup;
        }


        // --- Game Update Logic ---
        function updatePlayer() {
            // Smoothly interpolate player's X position to the target lane
            playerCar.position.x += (playerTargetX - playerCar.position.x) * 0.15; // <-- CHANGED

            // --- ADDED: Car Tilt ---
            const targetTilt = (playerTargetX - playerCar.position.x) * -0.05; // Tilt into the turn
            // Smoothly interpolate rotation
            playerCar.rotation.z += (targetTilt - playerCar.rotation.z) * 0.1;

            // Update the collision box to follow the player's body
            const body = playerCar.children[0]; // Child 0 is the chassis
            playerCar.userData.box.setFromObject(body);
        }

        function updateRoadLines(currentSpeed) {
            roadLines.forEach(line => {
                line.position.z += currentSpeed;
                // Wrap lines around for infinite road effect
                if (line.position.z > DESPAWN_Z_POSITION) {
                    line.position.z -= ROAD_LENGTH * 4;
                }
            });
        }

        function updateObstacles(currentSpeed) {
            // Update combo timer
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer === 0) {
                    combo = 0;
                    comboDisplayEl.classList.add('hidden');
                }
            }

            // --- Update Enemies ---
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.mesh.position.z += currentSpeed;

                // Update collision box
                const body = enemy.mesh.children[0]; // Child 0 is the chassis
                enemy.mesh.userData.box.setFromObject(body);

                // Check for collision with player
                if (checkCollision(playerCar, enemy.mesh)) {
                    endGame();
                    return; // Stop processing obstacles this frame
                }

                // Check for despawning (off-screen)
                if (enemy.mesh.position.z > DESPAWN_Z_POSITION) {
                    // Check for near miss
                    const nearMiss = Math.abs(playerLane - enemy.lane) <= 1;
                    if (nearMiss && enemy.mesh.position.z < DESPAWN_Z_POSITION + 5) { // Check just as it passes
                        combo++;
                        maxCombo = Math.max(maxCombo, combo);
                        comboTimer = 180; // 3 seconds at 60fps
                        const bonusScore = 10 + (combo * 5);
                        score += bonusScore;

                        comboDisplayEl.classList.remove('hidden');
                        comboValueEl.textContent = combo;
                        comboDisplayEl.classList.add('pulse-animation');
                        setTimeout(() => comboDisplayEl.classList.remove('pulse-animation'), 500);

                        // Spawn combo particles
                        for (let j = 0; j < 3; j++) {
                            createParticle(enemy.mesh.position.clone(), 0xffd700); // Gold
                        }
                    } else {
                        // Standard score for dodging
                        score += 10;
                    }

                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                }
            }

            // --- Update Ambulances ---
            for (let i = ambulances.length - 1; i >= 0; i--) {
                const ambu = ambulances[i];
                ambu.mesh.position.z += currentSpeed * 1.5; // Ambulances are faster
                const body = ambu.mesh.children[0]; // Child 0 is the chassis
                ambu.mesh.userData.box.setFromObject(body);

                // Animate flashing light
                ambu.mesh.userData.flashingLight.visible = Math.floor(Date.now() / 200) % 2 === 0;

                if (checkCollision(playerCar, ambu.mesh)) {
                    endGame();
                    return;
                }

                if (ambu.mesh.position.z > DESPAWN_Z_POSITION) {
                    scene.remove(ambu.mesh);
                    ambulances.splice(i, 1);
                    score += 30 + (combo * 10); // Bonus for dodging fast ambulance

                    for (let j = 0; j < 8; j++) {
                        createParticle(ambu.mesh.position.clone(), 0x00ff00); // Green
                    }
                }
            }

            // --- Update Traffic Lights ---
            for (let i = trafficLights.length - 1; i >= 0; i--) {
                const light = trafficLights[i];
                light.mesh.position.z += currentSpeed;
                light.mesh.userData.box.setFromObject(light.mesh.children[0]);

                if (checkCollision(playerCar, light.mesh)) {
                    if (light.type === 'GREEN') {
                        // Collect green light for bonus
                        score += 100 + (combo * 20);
                        combo += 3;
                        maxCombo = Math.max(maxCombo, combo);
                        comboTimer = 180;
                        comboDisplayEl.classList.remove('hidden');
                        comboValueEl.textContent = combo;

                        for (let j = 0; j < 15; j++) {
                            createParticle(light.mesh.position.clone(), 0x00ff00); // Green
                        }

                        scene.remove(light.mesh);
                        trafficLights.splice(i, 1);
                    } else {
                        // Hit red light
                        endGame();
                        return;
                    }
                }

                if (light.mesh.position.z > DESPAWN_Z_POSITION) {
                    scene.remove(light.mesh);
                    trafficLights.splice(i, 1);
                }
            }

            // Update UI
            scoreEl.textContent = score;
            const speedMultiplier = isAccelerating ? 2.5 : (isBraking ? 0.4 : 1.0); // <-- CHANGED
            speedDisplayEl.textContent = (gameSpeed / 0.3 * speedMultiplier).toFixed(1) + 'x'; // <-- CHANGED

            // Increase game speed difficulty over time, but only when a multiple is *passed*
            if (score > 0 && Math.floor(score / 500) > Math.floor((score - 10) / 500)) { // <-- CHANGED
                gameSpeed = Math.min(gameSpeed + 0.02, 0.8); // Cap speed // <-- CHANGED
            }
        }

        function updateScenery(currentSpeed) {
            for (let i = scenery.length - 1; i >= 0; i--) {
                const obj = scenery[i];
                obj.position.z += currentSpeed;

                if (obj.position.z > DESPAWN_Z_POSITION) {
                    // Remove the group and all its children (lights, etc.)
                    scene.remove(obj);
                    scenery.splice(i, 1);
                }
            }
        }

        function checkCollision(objA, objB) {
            // Simple Axis-Aligned Bounding Box (AABB) collision detection
            if (objA.userData.box && objB.userData.box) {
                return objA.userData.box.intersectsBox(objB.userData.box);
            }
            return false;
        }

        // --- NEW: Update Coins ---
        function updateCoins(currentSpeed) {
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.mesh.position.z += currentSpeed;
                coin.mesh.rotation.y += 0.1; // Spin the coin

                // Update collision box (using the group's box)
                coin.mesh.userData.box.setFromCenterAndSize(
                    coin.mesh.position,
                    new THREE.Vector3(1.4, 1.4, 0.4) // A slightly larger, simpler box
                );

                // Check for collision with player
                if (checkCollision(playerCar, coin.mesh)) {
                    score += 25; // Add score for coin

                    // Spawn particles
                    for (let j = 0; j < 5; j++) {
                        createParticle(coin.mesh.position.clone(), COIN_COLOR);
                    }

                    scene.remove(coin.mesh);
                    coins.splice(i, 1);

                } else if (coin.mesh.position.z > DESPAWN_Z_POSITION) {
                    // Check for despawning (off-screen)
                    scene.remove(coin.mesh);
                    coins.splice(i, 1);
                }
            }
        }

        // --- Object Spawning ---
        function spawnEnemy() {
            const spawnChance = 0.008 + (gameSpeed - 0.2) * 0.02;
            if (Math.random() < spawnChance) {
                const lane = random(0, LANE_COUNT - 1);
                // Check if lane is clear before spawning
                const canSpawn = enemies.every(e => e.lane !== lane || e.mesh.position.z > lastSpawnZ + CAR_BODY_DEPTH * 4);

                if (canSpawn) {
                    const color = ENEMY_COLORS[random(0, ENEMY_COLORS.length - 1)];
                    const mesh = createCar(color);
                    mesh.position.set(laneToX(lane), 0, SPAWN_Z_POSITION);
                    enemies.push({ mesh, lane });
                    scene.add(mesh);
                    lastSpawnZ = SPAWN_Z_POSITION; // Reset spawn timer
                }
            }
        }

        function spawnAmbulance() {
            const spawnChance = 0.003 + (gameSpeed - 0.2) * 0.005;
            if (Math.random() < spawnChance) {
                const lane = random(0, LANE_COUNT - 1);
                // Check if lane is clear
                const canSpawn = ambulances.every(a => a.lane !== lane || a.mesh.position.z > lastSpawnZ + CAR_BODY_DEPTH * 10);

                if (canSpawn) {
                    const mesh = createAmbulance();
                    mesh.position.set(laneToX(lane), 0, SPAWN_Z_POSITION);
                    ambulances.push({ mesh, lane });
                    scene.add(mesh);
                    lastSpawnZ = SPAWN_Z_POSITION;
                }
            }
        }

        function spawnTrafficLight() {
            const spawnChance = 0.001 + (gameSpeed - 0.2) * 0.002;
            if (Math.random() < spawnChance) {
                const lane = random(0, LANE_COUNT - 1);
                const type = (Math.random() < 0.6) ? 'GREEN' : 'RED'; // 60% green
                // Check if lane is clear
                const canSpawn = trafficLights.every(t => t.lane !== lane || t.mesh.position.z > lastSpawnZ + 50);

                if (canSpawn) {
                    const mesh = createTrafficLight(type);
                    mesh.position.set(laneToX(lane), 0, SPAWN_Z_POSITION);
                    trafficLights.push({ mesh, lane, type });
                    scene.add(mesh);
                    lastSpawnZ = SPAWN_Z_POSITION;
                }
            }
        }

        // --- NEW: Spawn Coins ---
        function spawnCoin() {
            const spawnChance = 0.015 + (gameSpeed - 0.3) * 0.02;
            if (Math.random() < spawnChance) {
                const lane = random(0, LANE_COUNT - 1);

                // Check if lane is clear at spawn point
                const canSpawn = enemies.every(e => e.lane !== lane || e.mesh.position.z > lastCoinSpawnZ + 50) &&
                    ambulances.every(a => a.lane !== lane || a.mesh.position.z > lastCoinSpawnZ + 50) &&
                    trafficLights.every(t => t.lane !== lane || t.mesh.position.z > lastCoinSpawnZ + 50);

                if (canSpawn) {
                    const trailLength = random(3, 8);
                    for (let i = 0; i < trailLength; i++) {
                        const mesh = createCoin();
                        const zPos = SPAWN_Z_POSITION - i * (CAR_BODY_DEPTH * 0.8); // Stagger coins
                        mesh.position.set(laneToX(lane), 1.5, zPos); // Raise coins off ground
                        coins.push({ mesh, lane });
                        scene.add(mesh);
                    }
                    lastCoinSpawnZ = SPAWN_Z_POSITION - trailLength * CAR_BODY_DEPTH;
                }
            }
            // Ensure coin spawn Z eventually resets if no coins spawn
            if (lastCoinSpawnZ < SPAWN_Z_POSITION - 50) {
                lastCoinSpawnZ += gameSpeed * 2;
            }
        }

        function spawnScenery() {
            const spawnChance = 0.01;
            if (Math.random() < spawnChance) {
                const isLeft = Math.random() < 0.5;
                const zPos = SPAWN_Z_POSITION - randomFloat(0, 50);

                let obj;
                let xPos;

                const randType = Math.random();
                if (randType < 0.4) {
                    // Street Light (close to road)
                    obj = createStreetLight();
                    xPos = (ROAD_WIDTH / 2 + 3) * (isLeft ? -1 : 1);
                    if (!isLeft) {
                        // Rotate light to face the road
                        obj.rotation.y = Math.PI;
                    }
                } else if (randType < 0.7) {
                    // Tree (medium distance)
                    obj = createTree();
                    xPos = (ROAD_WIDTH / 2 + randomFloat(5, 10)) * (isLeft ? -1 : 1);
                } else {
                    // Building (far distance)
                    obj = createBuilding();
                    xPos = (ROAD_WIDTH / 2 + randomFloat(15, 30)) * (isLeft ? -1 : 1);
                }

                obj.position.set(xPos, 0, zPos);
                scenery.push(obj);
                scene.add(obj);
            }
        }

        // --- Game Over ---
        function endGame() {
            if (gameOver) return; // Prevent calling multiple times
            gameOver = true;
            cancelAnimationFrame(animationFrameId); // Stop the game loop

            // Create explosion effect
            for (let i = 0; i < 30; i++) {
                createParticle(playerCar.position, PLAYER_COLOR);
                createParticle(playerCar.position, 0xffa500); // Orange
            }

            scene.remove(playerCar); // Hide player car

            // Show game over modal
            finalScoreEl.textContent = score;
            finalComboEl.textContent = maxCombo;
            modalEl.classList.remove('hidden');
            // Timeout to allow CSS transition to play
            setTimeout(() => {
                modalEl.querySelector('div').classList.remove('scale-90');
                modalEl.querySelector('div').classList.add('scale-100');
            }, 50);
        }

        // --- Main Game Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate); // Keep the loop running

            if (!gameOver) {
                // Calculate current speed
                let speedMultiplier = 1.0;
                if (isAccelerating) speedMultiplier = 2.5; // <-- CHANGED
                if (isBraking) speedMultiplier = 0.4; // <-- CHANGED
                const currentSpeed = gameSpeed * speedMultiplier;

                // Update Game Logic
                updatePlayer();
                updateRoadLines(currentSpeed);
                updateObstacles(currentSpeed);
                updateCoins(currentSpeed); // <-- ADDED
                updateScenery(currentSpeed);
                updateParticles();

                // Spawn new objects
                spawnEnemy();
                spawnAmbulance();
                spawnTrafficLight();
                spawnCoin(); // <-- ADDED
                spawnScenery();
            } else {
                // Keep updating particles even after game over for explosion
                updateParticles();
            }

            // --- ADDED: Camera FOV effect ---
            const targetFOV = isAccelerating ? 80 : (isBraking ? 70 : 75);
            camera.fov += (targetFOV - camera.fov) * 0.05;
            camera.updateProjectionMatrix();

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function addEventListeners() {
            // Keyboard
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);

            // Mobile Buttons
            const triggerHaptic = (style = 'medium') => {
                if (navigator.vibrate) {
                    // Simple pattern for feedback
                    navigator.vibrate(style === 'heavy' ? 30 : 10);
                }
            };

            const attachBtnEvents = (btn, startAction, endAction) => {
                if (!btn) return;
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startAction();
                    btn.classList.add('active');
                    triggerHaptic('heavy');
                }, { passive: false });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    endAction();
                    btn.classList.remove('active');
                });
                // Mouse
                btn.addEventListener('mousedown', (e) => {
                    startAction();
                    btn.classList.add('active');
                });
                btn.addEventListener('mouseup', (e) => {
                    endAction();
                    btn.classList.remove('active');
                });
                btn.addEventListener('mouseleave', (e) => {
                    endAction();
                    btn.classList.remove('active');
                });
            };

            attachBtnEvents(btnGas, () => isAccelerating = true, () => isAccelerating = false);
            attachBtnEvents(btnBrake, () => isBraking = true, () => isBraking = false);

            // Steering Wheel Logic - Drag to Steer
            if (steeringContainer && steeringWheel) {

                const getAngle = (clientX, clientY) => {
                    const rect = steeringContainer.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    return Math.atan2(clientY - centerY, clientX - centerX) * (180 / Math.PI);
                };

                const resetWheel = () => {
                    isDraggingWheel = false;
                    wheelCurrentRotation = 0;
                    hasTriggeredTurn = false;

                    // Re-enable transition for smooth return
                    steeringWheel.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                    steeringWheel.style.transform = `rotate(0deg)`;
                };

                steeringContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length > 0) {
                        isDraggingWheel = true;
                        // Disable transition for instant tracking
                        steeringWheel.style.transition = 'none';

                        const touch = e.touches[0];
                        // Calculate initial offset angle so the wheel doesn't jump to finger position
                        const angle = getAngle(touch.clientX, touch.clientY);
                        wheelInitAngle = angle - wheelCurrentRotation;
                    }
                }, { passive: false });

                steeringContainer.addEventListener('touchmove', (e) => {
                    if (!isDraggingWheel) return;
                    e.preventDefault();

                    const touch = e.touches[0];
                    const angle = getAngle(touch.clientX, touch.clientY);

                    // Update rotation
                    // We want the wheel to follow the finger relative to where we started
                    // But for a simple steering wheel, usually we just map the angle directly 
                    // or mapped from the "down" position (90 degrees). 
                    // Let's try simple relative tracking first.

                    let newRotation = angle - wheelInitAngle;

                    // Normalize to keep it sane (optional, but good if wrapping around)
                    // Clamp rotation to resemble real max lock (e.g. -90 to 90)
                    newRotation = Math.max(-100, Math.min(100, newRotation));

                    wheelCurrentRotation = newRotation;
                    steeringWheel.style.transform = `rotate(${wheelCurrentRotation}deg)`;

                    // Threshold Logic
                    const TURN_THRESHOLD = 30;
                    const RESET_THRESHOLD = 10;

                    if (!hasTriggeredTurn) {
                        if (wheelCurrentRotation < -TURN_THRESHOLD) {
                            movePlayer(-1);
                            triggerHaptic('heavy');
                            hasTriggeredTurn = true;
                        } else if (wheelCurrentRotation > TURN_THRESHOLD) {
                            movePlayer(1);
                            triggerHaptic('heavy');
                            hasTriggeredTurn = true;
                        }
                    } else {
                        // Reset trigger if user brings wheel back to center
                        if (Math.abs(wheelCurrentRotation) < RESET_THRESHOLD) {
                            hasTriggeredTurn = false;
                            triggerHaptic('light'); // Subtle click on center
                        }
                    }

                }, { passive: false });

                steeringContainer.addEventListener('touchend', resetWheel);
                steeringContainer.addEventListener('touchcancel', resetWheel);

                // Mouse fallback
                steeringContainer.addEventListener('mousedown', (e) => {
                    isDraggingWheel = true;
                    steeringWheel.style.transition = 'none';
                    const angle = getAngle(e.clientX, e.clientY);
                    wheelInitAngle = angle - wheelCurrentRotation;
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDraggingWheel) return;
                    const angle = getAngle(e.clientX, e.clientY);
                    let newRotation = angle - wheelInitAngle;
                    newRotation = Math.max(-100, Math.min(100, newRotation));

                    wheelCurrentRotation = newRotation;
                    steeringWheel.style.transform = `rotate(${wheelCurrentRotation}deg)`;

                    const TURN_THRESHOLD = 30;
                    const RESET_THRESHOLD = 10;

                    if (!hasTriggeredTurn) {
                        if (wheelCurrentRotation < -TURN_THRESHOLD) {
                            movePlayer(-1);
                            hasTriggeredTurn = true;
                        } else if (wheelCurrentRotation > TURN_THRESHOLD) {
                            movePlayer(1);
                            hasTriggeredTurn = true;
                        }
                    } else {
                        if (Math.abs(wheelCurrentRotation) < RESET_THRESHOLD) {
                            hasTriggeredTurn = false;
                        }
                    }
                });

                window.addEventListener('mouseup', resetWheel);
            }

            // Touch Controls (Swiping) - Keep as fallback
            window.addEventListener('touchstart', handleTouchStart, { passive: false });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleTouchEnd);

            // Restart Button
            restartButton.addEventListener('click', resetGame);

            // Window Resize
            window.addEventListener('resize', handleResize);
        }

        function handleKeyDown(e) {
            if (gameOver) return;
            switch (e.key) {
                case 'ArrowLeft':
                case 'a':
                    movePlayer(-1);
                    break;
                case 'ArrowRight':
                case 'd':
                    movePlayer(1);
                    break;
                case 'ArrowUp':
                case 'w':
                    isAccelerating = true;
                    break;
                case 'ArrowDown':
                case 's':
                    isBraking = true;
                    break;
            }
        }

        function handleKeyUp(e) {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    isAccelerating = false;
                    break;
                case 'ArrowDown':
                case 's':
                    isBraking = false;
                    break;
            }
        }

        function movePlayer(direction) {
            playerLane = Math.max(0, Math.min(LANE_COUNT - 1, playerLane + direction));
            playerTargetX = laneToX(playerLane);
        }

        function handleTouchStart(e) {
            // Only track swipes if NOT touching controls
            // Check if target is inside mobileControls
            if (e.target.closest && e.target.closest('#mobileControls')) {
                return;
            }
            touchStartX = e.touches[0].clientX;
        }

        function handleTouchMove(e) {
            if (touchStartX === 0) return;
            touchEndX = e.touches[0].clientX;
        }

        function handleTouchEnd() {
            if (gameOver || touchStartX === 0) {
                touchStartX = 0;
                touchEndX = 0;
                return;
            }

            const diff = touchEndX - touchStartX;

            if (diff > SWIPE_THRESHOLD) {
                // Swipe Right
                movePlayer(1);
            } else if (diff < -SWIPE_THRESHOLD) {
                // Swipe Left
                movePlayer(-1);
            }

            // Reset for next swipe
            touchStartX = 0;
            touchEndX = 0;
        }

        function updateCanvasSize() {
            // Prioritize smaller canvas on tall/narrow mobile screens
            if (window.innerWidth < 768 && window.innerHeight > window.innerWidth) {
                CANVAS_WIDTH = Math.min(600, window.innerWidth * 0.95);
                CANVAS_HEIGHT = Math.min(500, window.innerHeight * 0.5);
            } else {
                // Standard logic for desktop or landscape mobile
                CANVAS_WIDTH = Math.min(600, window.innerWidth * 0.9);
                CANVAS_HEIGHT = Math.min(600, window.innerHeight * 0.6);
            }

            if (canvas) {
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
            }
        }

        function handleResize() {
            updateCanvasSize();

            // Update camera aspect ratio and renderer size
            if (camera && renderer) {
                camera.aspect = CANVAS_WIDTH / CANVAS_HEIGHT;
                camera.updateProjectionMatrix();
                renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
            }
        }

        // --- Start the game ---
        init();

    </script>

</body>

</html>