<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>City Driving: Night City</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            touch-action: none;
            background-color: #111827;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            margin: 0 auto;
        }

        .game-button {
            display: inline-block;
            background-image: linear-gradient(to right, #3b82f6, #2563eb);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.2s ease-in-out;
            border: none;
            cursor: pointer;
            user-select: none;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-image: linear-gradient(to right, #2563eb, #3b82f6);
        }

        /* Powerup & Status UI */
        #statusContainer {
            position: absolute;
            top: 70px;
            right: 20px;
            left: auto;
            transform: none;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: none;
            z-index: 20;
        }

        .status-badge {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .status-active { opacity: 1; }
        .shield-active { border-color: #3b82f6; color: #93c5fd; }
        .magnet-active { border-color: #ef4444; color: #fca5a5; }

        /* Driving Tips UI */
        #tipContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            transform: none;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 20;
        }
        
        #tipIcon { font-size: 1.2rem; }
        #tipText { font-size: 0.9rem; font-weight: 500; color: #e5e7eb; }

        .touch-hint {
            position: absolute;
            bottom: 20px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            text-transform: uppercase;
            font-weight: bold;
        }
        .hint-left { left: 20px; }
        .hint-right { right: 20px; }

        @media (max-width: 768px) {
            .desktop-hint { display: none; }
            #tipContainer { top: 15px; right: 15px; width: auto; font-size: 0.8rem; padding: 6px 12px; }
            #statusContainer { top: 60px; right: 15px; }
        }
    </style>
</head>

<body class="bg-gray-900 min-h-screen flex flex-col items-center justify-center text-white p-4">

    <h1 class="text-4xl md:text-5xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 select-none">
        City Driving
    </h1>

    <div class="mb-2 flex gap-6 text-xl font-medium select-none">
        <div>Score: <span id="score" class="font-bold text-yellow-300">0</span></div>
        <div>Speed: <span id="speedDisplay" class="font-bold text-cyan-300">1.0x</span></div>
        <div id="comboDisplay" class="font-bold text-green-400 hidden">Combo: <span id="comboValue">0</span>x</div>
    </div>

    <!-- Time UI -->
    <div id="tipContainer">
        <span id="tipIcon">‚òÄÔ∏è</span>
        <span id="tipText">Day</span>
    </div>

    <!-- Powerup Status -->
    <div id="statusContainer">
        <div id="shieldBadge" class="status-badge shield-active">
            <span>üõ°Ô∏è</span> SHIELD
        </div>
        <div id="magnetBadge" class="status-badge magnet-active">
            <span>üß≤</span> MAGNET
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="touch-hint hint-left md:hidden">Hold Left: Brake</div>
    <div class="touch-hint hint-right md:hidden">Hold Right: Gas</div>

    <p class="mt-4 text-gray-400 text-sm md:text-base text-center desktop-hint select-none">
        Keys: Left/Right or A/D (Move), Up/W (Race), Down/S (Brake)
    </p>

    <div id="gameOverModal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white text-gray-900 p-8 md:p-12 rounded-lg shadow-2xl text-center transform scale-90 transition-all">
            <h2 class="text-3xl font-bold mb-4">Game Over!</h2>
            <p class="text-xl mb-2">
                Final Score: <span id="finalScore" class="font-bold text-blue-600">0</span>
            </p>
            <p class="text-lg mb-6">
                Max Combo: <span id="finalCombo" class="font-bold text-green-600">0</span>x
            </p>
            <button id="restartButton" class="game-button">
                Play Again
            </button>
        </div>
    </div>

    <script type="module">
        // --- Sound Manager ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        let engineOsc1, engineOsc2, engineNoise, engineFilter, engineMasterGain;

        function createNoiseBuffer() {
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            return buffer;
        }

        const noiseBuffer = createNoiseBuffer();

        function startEngine() {
            if (engineOsc1) return;
            engineOsc1 = audioCtx.createOscillator();
            engineOsc2 = audioCtx.createOscillator();
            engineNoise = audioCtx.createBufferSource();
            engineFilter = audioCtx.createBiquadFilter();
            engineMasterGain = audioCtx.createGain();
            
            engineOsc1.type = 'sawtooth'; engineOsc1.frequency.value = 60; 
            engineOsc2.type = 'sine'; engineOsc2.frequency.value = 30;
            engineNoise.buffer = noiseBuffer; engineNoise.loop = true;
            engineFilter.type = 'lowpass'; engineFilter.Q.value = 2;

            engineOsc1.connect(engineFilter); engineOsc2.connect(engineFilter);
            const noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0.05;
            engineNoise.connect(noiseGain); noiseGain.connect(engineMasterGain);
            engineFilter.connect(engineMasterGain); engineMasterGain.connect(audioCtx.destination);

            engineOsc1.start(); engineOsc2.start(); engineNoise.start();
            engineMasterGain.gain.value = 0.1; engineFilter.frequency.value = 200;
        }

        function updateEngine(speed, accelerating) {
            if (!engineOsc1) return;
            const now = audioCtx.currentTime;
            const baseFreq = 60;
            const rpmMultiplier = 1 + (speed * 3);
            const targetFreq = baseFreq * rpmMultiplier;
            engineOsc1.frequency.setTargetAtTime(targetFreq, now, 0.1);
            engineOsc2.frequency.setTargetAtTime(targetFreq * 0.5, now, 0.1);
            engineFilter.frequency.setTargetAtTime(200 + (speed * 2000), now, 0.1);
            engineMasterGain.gain.setTargetAtTime(accelerating ? 0.2 + (speed*0.1) : 0.05 + (speed*0.05), now, 0.1);
        }
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (audioCtx.state === 'running' && !engineOsc1) startEngine();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'coin') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
                gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'break') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'boost') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(600, now + 0.3);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            }
        }

        // --- DOM ---
        const canvas = document.getElementById('gameCanvas');
        const scoreEl = document.getElementById('score');
        const speedDisplayEl = document.getElementById('speedDisplay');
        const comboDisplayEl = document.getElementById('comboDisplay');
        const comboValueEl = document.getElementById('comboValue');
        const modalEl = document.getElementById('gameOverModal');
        const finalScoreEl = document.getElementById('finalScore');
        const finalComboEl = document.getElementById('finalCombo');
        const restartButton = document.getElementById('restartButton');
        const tipTextEl = document.getElementById('tipText');
        const tipIconEl = document.getElementById('tipIcon');
        const shieldBadge = document.getElementById('shieldBadge');
        const magnetBadge = document.getElementById('magnetBadge');

        // --- Constants ---
        const LANE_COUNT = 3; const LANE_WIDTH = 5; const ROAD_WIDTH = LANE_COUNT * LANE_WIDTH; const ROAD_LENGTH = 100;
        const CAR_BODY_WIDTH = 2.5; const CAR_BODY_HEIGHT = 1.0; const CAR_BODY_DEPTH = 4.5;
        const WHEEL_RADIUS = 0.5; const WHEEL_THICKNESS = 0.3;
        const PLAYER_Z_POSITION = 15; const SPAWN_Z_POSITION = -ROAD_LENGTH * 1.5; const DESPAWN_Z_POSITION = PLAYER_Z_POSITION + 20;
        
        // Colors
        const PLAYER_COLOR = 0x3b82f6; const ROAD_COLOR = 0x34495e; const LINE_COLOR = 0xffffff;
        const TREE_TRUNK_COLOR = 0x5d4037; const TREE_LEAVES_COLOR = 0x2e7d32;
        const COIN_COLOR = 0xffd700; const SHIELD_COLOR = 0x06b6d4; const MAGNET_COLOR = 0xf43f5e;
        
        // --- State ---
        let scene, camera, renderer;
        let playerCar, playerShieldMesh;
        let roadLines = [];
        let enemies = [], ambulances = [], police = [], trafficLights = [], scenery = [], coins = [], powerups = [], particles = [];
        let score = 0, gameSpeed = 0.3, gameOver = false, animationFrameId;
        let playerLane = 1, playerTargetX = 0, isAccelerating = false, isBraking = false;
        let combo = 0, maxCombo = 0, comboTimer = 0, lastSpawnZ = SPAWN_Z_POSITION;
        let hasShield = false, hasMagnet = false, magnetTimer = 0, invincibleTimer = 0;
        let CANVAS_WIDTH, CANVAS_HEIGHT, touchStartX = 0, touchEndX = 0;

        // Day/Night Cycle
        let timeOfDay = 0; // 0.0 to 1.0 (0=Noon, 0.5=Midnight)
        let sunLight, ambientLight;
        let windowTextures = [];

        // --- Utils ---
        function random(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function randomFloat(min, max) { return Math.random() * (max - min) + min; }
        function laneToX(lane) { return (lane - (LANE_COUNT - 1) / 2) * LANE_WIDTH; }

        function createWindowTextures() {
            windowTextures = [];
            const colors = ['#fde047', '#fb923c', '#e0f2fe']; // Yellow, Orange, Blueish tint
            
            for(let i=0; i<3; i++) {
                const cvs = document.createElement('canvas');
                cvs.width = 64; cvs.height = 128;
                const ctx = cvs.getContext('2d');
                
                // Building base color (dark)
                ctx.fillStyle = '#222';
                ctx.fillRect(0,0,64,128);
                
                // Windows
                ctx.fillStyle = colors[i];
                for(let y=10; y<120; y+=15) {
                    for(let x=8; x<56; x+=16) {
                        // Randomly light up windows
                        if(Math.random() > 0.3) {
                            ctx.fillRect(x, y, 10, 10);
                        }
                    }
                }
                const tex = new THREE.CanvasTexture(cvs);
                tex.magFilter = THREE.NearestFilter;
                windowTextures.push(tex);
            }
        }

        // --- Init ---
        function init() {
            createWindowTextures();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 40, 130);

            updateCanvasSize();
            camera = new THREE.PerspectiveCamera(75, CANVAS_WIDTH / CANVAS_HEIGHT, 0.1, 1000);
            camera.position.set(0, 8, PLAYER_Z_POSITION + 7);
            camera.lookAt(0, 0, PLAYER_Z_POSITION - 10);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
            renderer.shadowMap.enabled = true;

            ambientLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.6);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(-20, 50, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.top = 50; sunLight.shadow.camera.bottom = -50;
            sunLight.shadow.camera.left = -50; sunLight.shadow.camera.right = 50;
            scene.add(sunLight);

            // Road & Environment
            const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH * 3);
            const roadMaterial = new THREE.MeshStandardMaterial({ color: ROAD_COLOR, roughness: 0.8, metalness: 0.1 });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.z = -ROAD_LENGTH / 2 + PLAYER_Z_POSITION;
            road.receiveShadow = true;
            scene.add(road);

            const sidewalkGeom = new THREE.PlaneGeometry(5, ROAD_LENGTH * 3);
            const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x9ca3af });
            const leftWalk = new THREE.Mesh(sidewalkGeom, sidewalkMat);
            leftWalk.rotation.x = -Math.PI / 2; leftWalk.position.set(-ROAD_WIDTH/2 - 2.5, 0.02, road.position.z);
            leftWalk.receiveShadow = true; scene.add(leftWalk);
            
            const rightWalk = new THREE.Mesh(sidewalkGeom, sidewalkMat);
            rightWalk.rotation.x = -Math.PI / 2; rightWalk.position.set(ROAD_WIDTH/2 + 2.5, 0.02, road.position.z);
            rightWalk.receiveShadow = true; scene.add(rightWalk);

            const lineMat = new THREE.MeshStandardMaterial({ color: LINE_COLOR });
            const lineGeom = new THREE.PlaneGeometry(0.3, 4);
            for (let i = 1; i < LANE_COUNT; i++) {
                const lineX = laneToX(i - 1) + LANE_WIDTH / 2;
                for (let z = -ROAD_LENGTH * 2; z < ROAD_LENGTH * 2; z += 8) {
                    const line = new THREE.Mesh(lineGeom, lineMat);
                    line.rotation.x = -Math.PI / 2; line.position.set(lineX, 0.03, z);
                    scene.add(line); roadLines.push(line);
                }
            }

            addEventListeners();
            resetGame();
        }

        function resetGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (engineMasterGain) engineMasterGain.gain.setTargetAtTime(0.1, audioCtx.currentTime, 0.5);

            score = 0; gameSpeed = 0.3; gameOver = false;
            isAccelerating = false; isBraking = false;
            combo = 0; maxCombo = 0; comboTimer = 0;
            lastSpawnZ = SPAWN_Z_POSITION;
            
            hasShield = false; hasMagnet = false; magnetTimer = 0; invincibleTimer = 0;
            shieldBadge.classList.remove('status-active');
            magnetBadge.classList.remove('status-active');
            
            timeOfDay = 0.8; // Start at morning/day
            
            if (playerCar) scene.remove(playerCar);
            if (playerShieldMesh) scene.remove(playerShieldMesh);
            
            [...enemies, ...ambulances, ...police, ...trafficLights, ...scenery, ...coins, ...powerups].forEach(obj => scene.remove(obj.mesh));
            particles.forEach(p => scene.remove(p));
            enemies=[]; ambulances=[]; police=[]; trafficLights=[]; scenery=[]; coins=[]; powerups=[]; particles=[];

            for (let z = PLAYER_Z_POSITION; z > SPAWN_Z_POSITION * 1.5; z -= 15) spawnSceneryRow(z);

            playerCar = createCar(PLAYER_COLOR, true);
            playerLane = 1; playerTargetX = laneToX(playerLane);
            playerCar.position.set(playerTargetX, 0, PLAYER_Z_POSITION);
            scene.add(playerCar);
            
            const shieldGeom = new THREE.SphereGeometry(2.5, 16, 16);
            const shieldMat = new THREE.MeshBasicMaterial({ color: 0x3b82f6, transparent: true, opacity: 0.3, wireframe: true });
            playerShieldMesh = new THREE.Mesh(shieldGeom, shieldMat);
            playerShieldMesh.visible = false;
            scene.add(playerShieldMesh);

            scoreEl.textContent = score; speedDisplayEl.textContent = '1.0x';
            comboDisplayEl.classList.add('hidden'); modalEl.classList.add('hidden');
            
            animate();
        }

        function updateTimeOfDay() {
            timeOfDay += 0.0003; // Time speed
            if (timeOfDay > 1) timeOfDay = 0;

            const sunColor = new THREE.Color();
            const skyColor = new THREE.Color();
            const fogColor = new THREE.Color();
            let ambientInt = 0.5;
            let sunInt = 1.0;
            let buildingEmissive = 0;
            let streetLightInt = 0;
            let stateLabel = "";

            if (timeOfDay < 0.25) { 
                // NIGHT (0.0 - 0.25)
                stateLabel = "Night";
                skyColor.setHex(0x050510); fogColor.setHex(0x050510);
                sunColor.setHex(0x444488); // Moonlight
                ambientInt = 0.2; sunInt = 0.2;
                buildingEmissive = 1.0; streetLightInt = 1.5;
                tipIconEl.textContent = "üåô";
            } else if (timeOfDay < 0.35) {
                // DAWN (0.25 - 0.35)
                stateLabel = "Dawn";
                const t = (timeOfDay - 0.25) * 10; // 0 to 1
                skyColor.lerpColors(new THREE.Color(0x050510), new THREE.Color(0xffaa55), t);
                fogColor.copy(skyColor);
                sunColor.setHex(0xffaa55);
                ambientInt = 0.2 + (t * 0.4); sunInt = 0.2 + (t * 0.6);
                buildingEmissive = 1.0 - t; streetLightInt = 1.5 * (1-t);
                tipIconEl.textContent = "üåÖ";
            } else if (timeOfDay < 0.75) {
                // DAY (0.35 - 0.75)
                stateLabel = "Day";
                skyColor.setHex(0x87CEEB); fogColor.setHex(0x87CEEB);
                sunColor.setHex(0xffffff);
                ambientInt = 0.6; sunInt = 1.0;
                buildingEmissive = 0; streetLightInt = 0;
                tipIconEl.textContent = "‚òÄÔ∏è";
            } else if (timeOfDay < 0.85) {
                // DUSK (0.75 - 0.85)
                stateLabel = "Dusk";
                const t = (timeOfDay - 0.75) * 10;
                skyColor.lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0x993355), t);
                fogColor.copy(skyColor);
                sunColor.setHex(0xff8833);
                ambientInt = 0.6 - (t * 0.4); sunInt = 1.0 - (t * 0.8);
                buildingEmissive = t; streetLightInt = t * 1.5;
                tipIconEl.textContent = "üåá";
            } else {
                // NIGHT Transition (0.85 - 1.0)
                stateLabel = "Night";
                const t = (timeOfDay - 0.85) / 0.15;
                skyColor.lerpColors(new THREE.Color(0x993355), new THREE.Color(0x050510), t);
                fogColor.copy(skyColor);
                sunColor.lerpColors(new THREE.Color(0xff8833), new THREE.Color(0x444488), t);
                ambientInt = 0.2; sunInt = 0.2;
                buildingEmissive = 1.0; streetLightInt = 1.5;
                tipIconEl.textContent = "üåô";
            }

            tipTextEl.textContent = stateLabel;
            scene.background.copy(skyColor);
            scene.fog.color.copy(fogColor);
            sunLight.color.copy(sunColor);
            sunLight.intensity = sunInt;
            ambientLight.intensity = ambientInt;

            // Update Environment
            scenery.forEach(s => {
                if (s.isBuilding) {
                    s.mesh.material.emissiveIntensity = buildingEmissive;
                }
                if (s.isStreetLight) {
                    s.mesh.userData.light.intensity = streetLightInt;
                }
            });
        }

        // --- Core Functions (Added) ---
        function updatePlayer() {
            playerCar.position.x += (playerTargetX - playerCar.position.x) * 0.15;
            playerCar.rotation.z = (playerTargetX - playerCar.position.x) * -0.05;
            playerCar.userData.box.setFromObject(playerCar.children[0]);
        }

        function updateRoadLines(speed) {
            roadLines.forEach(line => {
                line.position.z += speed;
                if (line.position.z > DESPAWN_Z_POSITION) line.position.z -= ROAD_LENGTH * 4;
            });
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.01;
                p.material.opacity -= 0.02;
                if(p.material.opacity <= 0 || p.position.y < 0) {
                    scene.remove(p);
                    particles.splice(i,1);
                }
            }
        }

        function endGame() {
            if (gameOver) return;
            gameOver = true;
            cancelAnimationFrame(animationFrameId);
            
            // Explosion particles
            for(let i=0; i<30; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xff5500, transparent: true}));
                p.position.copy(playerCar.position);
                p.userData.vel = new THREE.Vector3(randomFloat(-1,1), randomFloat(1,3), randomFloat(-1,1));
                scene.add(p);
                particles.push(p);
            }
            
            scene.remove(playerCar);
            if(engineMasterGain) engineMasterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);

            finalScoreEl.textContent = score;
            finalComboEl.textContent = maxCombo;
            modalEl.classList.remove('hidden');
            
            // Render one last frame to show explosion start
            renderer.render(scene, camera);
        }

        // --- Objects ---
        function createBuilding() {
            const h = randomFloat(10, 25);
            const w = randomFloat(6, 12);
            const d = randomFloat(6, 12);
            
            const tex = windowTextures[random(0, windowTextures.length - 1)];
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                map: tex, 
                emissive: 0xffffff, 
                emissiveMap: tex,
                emissiveIntensity: 0 // Controlled by time of day
            });
            
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.y = h/2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createStreetLight() {
            const group = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 10, 6), new THREE.MeshStandardMaterial({ color: 0x1f2937 }));
            pole.position.y = 5; group.add(pole);
            const arm = new THREE.Mesh(new THREE.BoxGeometry(3, 0.15, 0.15), new THREE.MeshStandardMaterial({ color: 0x1f2937 }));
            arm.position.set(1, 9.8, 0); group.add(arm);
            
            // Bulb housing
            const bulb = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 0.4), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffffaa }));
            bulb.position.set(2.2, 9.6, 0); group.add(bulb);
            
            const light = new THREE.PointLight(0xffaa00, 0, 30);
            light.position.set(2.2, 9, 0);
            group.add(light);
            group.userData.light = light; // Ref for update
            
            return group;
        }

        // --- Existing Object Logic (Simplified) ---
        function createCar(color, isPlayer=false) { 
            const car = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.2 });
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(CAR_BODY_WIDTH, 0.8, CAR_BODY_DEPTH), bodyMat);
            chassis.position.y = 0.9; chassis.castShadow = true; car.add(chassis);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(CAR_BODY_WIDTH*0.75, 0.6, CAR_BODY_DEPTH*0.4), new THREE.MeshStandardMaterial({ color: 0x111, roughness: 0}));
            cabin.position.set(0, 1.6, -0.2); car.add(cabin);
            
            // Lights
            if(isPlayer) {
                const hl = new THREE.SpotLight(0xffffff, 2, 60, 0.5, 0.5); hl.position.set(0,1,-2.2); hl.target.position.set(0,0,-20);
                car.add(hl); car.add(hl.target);
            }
            // Wheels
            const wG = new THREE.CylinderGeometry(0.5,0.5,0.3,16); wG.rotateZ(Math.PI/2); const wM=new THREE.MeshStandardMaterial({color:0x111});
            [[-1,0.7],[1,0.7],[-1,-0.7],[1,-0.7]].forEach(p=>{const w=new THREE.Mesh(wG,wM); w.position.set(p[0]*1.25,0.5,p[1]*2.25); car.add(w);});
            car.userData.box = new THREE.Box3().setFromObject(chassis);
            return car;
        }
        function createTree() { 
            const g = new THREE.Group(); 
            g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.4,2), new THREE.MeshStandardMaterial({color:0x5d4037}))); 
            const l = new THREE.Mesh(new THREE.DodecahedronGeometry(1.5), new THREE.MeshStandardMaterial({color:0x2e7d32})); l.position.y=2; g.add(l);
            g.children[0].position.y=1; return g; 
        }
        function createPowerup(type) { 
            const g=new THREE.Group(); 
            // FIXED: Raised spawn height to 1.5 to align with car chassis collision box
            const m=new THREE.Mesh(type==='SHIELD'?new THREE.IcosahedronGeometry(0.6):new THREE.BoxGeometry(0.7,0.7,0.7), new THREE.MeshStandardMaterial({color:type==='SHIELD'?SHIELD_COLOR:MAGNET_COLOR, emissiveIntensity:0.5, emissive:type==='SHIELD'?SHIELD_COLOR:MAGNET_COLOR})); 
            g.add(m); g.userData.box=new THREE.Box3().setFromObject(m); g.userData.type=type; return g; 
        }
        function createCoin() { 
            const c=new THREE.Mesh(new THREE.CylinderGeometry(0.7,0.7,0.1,16), new THREE.MeshStandardMaterial({color:COIN_COLOR, emissive:0xaa8800})); 
            c.rotation.x=Math.PI/2; const g=new THREE.Group(); g.add(c); g.userData.box=new THREE.Box3().setFromObject(c); return g; 
        }

        // --- Core Loops ---
        function updateGameObjects(speed) {
            if(comboTimer>0){comboTimer--; if(comboTimer===0){combo=0;comboDisplayEl.classList.add('hidden');}}
            scenery.forEach((s,i)=>{s.mesh.position.z+=speed; if(s.mesh.position.z>DESPAWN_Z_POSITION){scene.remove(s.mesh);scenery.splice(i,1);}});
            
            const updateObj = (list, type) => {
                for(let i=list.length-1; i>=0; i--) {
                    let o = list[i]; 
                    o.mesh.position.z+=speed; 
                    
                    // FIXED: Rotation animation for powerups
                    if(type==='POWERUP') { o.mesh.rotation.y += 0.05; o.mesh.rotation.x += 0.05; }
                    
                    o.mesh.updateMatrixWorld(); 
                    o.mesh.userData.box.setFromObject(o.mesh.children[0]);
                    
                    if(type==='COIN' && hasMagnet && o.mesh.position.z > -40 && o.mesh.position.z < 20) {
                        o.mesh.position.x += (playerCar.position.x - o.mesh.position.x)*0.2;
                        o.mesh.position.z += (playerCar.position.z - o.mesh.position.z)*0.2;
                    }
                    if(checkCollision(playerCar, o.mesh)) {
                        if(type==='ENEMY'||type==='POLICE') { if(!hasShield && invincibleTimer===0) endGame(); else { if(hasShield) {hasShield=false; shieldBadge.classList.remove('status-active'); playSound('break'); invincibleTimer=60;} scene.remove(o.mesh); list.splice(i,1); } }
                        else if(type==='COIN') { score+=25; playSound('coin'); scene.remove(o.mesh); list.splice(i,1); }
                        else if(type==='POWERUP') { playSound('boost'); if(o.type==='SHIELD'){hasShield=true;shieldBadge.classList.add('status-active');}else{hasMagnet=true;magnetTimer=600;magnetBadge.classList.add('status-active');} scene.remove(o.mesh); list.splice(i,1); }
                    } else if(o.mesh.position.z>DESPAWN_Z_POSITION) { if(type==='ENEMY') score+=10; scene.remove(o.mesh); list.splice(i,1); }
                }
            };
            updateObj(enemies, 'ENEMY'); updateObj(police, 'POLICE'); updateObj(powerups, 'POWERUP'); updateObj(coins, 'COIN');
            
            // Magnet Timer
            if(hasMagnet) { magnetTimer--; if(magnetTimer<=0) {hasMagnet=false; magnetBadge.classList.remove('status-active');} }
            if(invincibleTimer>0) invincibleTimer--;
            
            // Shield Mesh
            playerShieldMesh.visible = hasShield;
            playerShieldMesh.position.copy(playerCar.position); playerShieldMesh.position.y+=1; playerShieldMesh.rotation.y+=0.1;
        }

        function spawnSceneryRow(zPos) {
            [1, -1].forEach(side => {
                if(Math.random()>0.3) {
                    const r = Math.random();
                    let m, isB=false, isL=false;
                    let x = (side*ROAD_WIDTH/2) + (side*5) + (side*randomFloat(0,5));
                    if(r<0.2) { m=createStreetLight(); x=side*(ROAD_WIDTH/2+2.5); m.rotation.y=side*-Math.PI/2; isL=true; }
                    else if(r<0.5) m=createTree();
                    else { m=createBuilding(); x+=side*10; isB=true; }
                    m.position.set(x,0,zPos); scene.add(m);
                    scenery.push({mesh:m, isBuilding:isB, isStreetLight:isL});
                }
            });
        }
        
        function spawnObjects() {
            if(Math.random()<0.05) spawnSceneryRow(SPAWN_Z_POSITION);
            if(Math.random()<0.015 && isLaneClear(1)) {
                 const lane=random(0,2); 
                 if(isLaneClear(lane)) {
                     const m=createCar(0xff0000); m.position.set(laneToX(lane),0,SPAWN_Z_POSITION); 
                     enemies.push({mesh:m, lane}); scene.add(m); lastSpawnZ=SPAWN_Z_POSITION;
                 }
            }
            if(Math.random()<0.01 && isLaneClear(1)) {
                for(let k=0;k<5;k++){
                    const l=random(0,2); const m=createCoin(); m.position.set(laneToX(l),1,SPAWN_Z_POSITION-k*4);
                    coins.push({mesh:m,lane:l}); scene.add(m);
                }
            }
            if(Math.random()<0.003) {
                 const l=random(0,2); const t=Math.random()>0.5?'SHIELD':'MAGNET'; const m=createPowerup(t);
                 // FIXED: Spawn height Y=1.2 to prevent underground spawning
                 m.position.set(laneToX(l),1.2,SPAWN_Z_POSITION); powerups.push({mesh:m,lane:l,type:t}); scene.add(m); lastSpawnZ=SPAWN_Z_POSITION;
            }
        }
        function isLaneClear(l) { return lastSpawnZ < SPAWN_Z_POSITION + 20; }
        function checkCollision(a,b) { return a.userData.box && b.userData.box && a.userData.box.intersectsBox(b.userData.box); }

        // --- Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if(!gameOver) {
                let speedMult = isAccelerating?2.0:(isBraking?0.5:1.0);
                let currentSpeed = gameSpeed*speedMult;
                
                updateTimeOfDay();
                updateEngine(currentSpeed, isAccelerating);
                updatePlayer();
                updateRoadLines(currentSpeed);
                updateGameObjects(currentSpeed);
                updateParticles(); // Add particle update
                spawnObjects();
                
                scoreEl.textContent = score;
                speedDisplayEl.textContent = (currentSpeed*3).toFixed(1)+'x';
                gameSpeed = Math.min(gameSpeed+0.0001, 1.0);
                
                camera.fov += ((isAccelerating?85:75)-camera.fov)*0.05;
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);
            } else {
                updateParticles(); // Keep particles moving after death
                renderer.render(scene, camera);
            }
        }
        
        // --- Input ---
        function movePlayer(d) { playerLane=Math.max(0,Math.min(2,playerLane+d)); playerTargetX=laneToX(playerLane); }
        function updateCanvasSize() { 
            CANVAS_WIDTH=Math.min(600, window.innerWidth); CANVAS_HEIGHT=Math.min(600, window.innerHeight*0.7);
            canvas.width=CANVAS_WIDTH; canvas.height=CANVAS_HEIGHT;
            if(camera){camera.aspect=CANVAS_WIDTH/CANVAS_HEIGHT; camera.updateProjectionMatrix();}
            if(renderer)renderer.setSize(CANVAS_WIDTH,CANVAS_HEIGHT);
        }
        function addEventListeners() {
            window.addEventListener('resize', updateCanvasSize);
            const resume=()=>{if(audioCtx.state==='suspended')audioCtx.resume(); if(!engineOsc1)startEngine();};
            window.addEventListener('keydown', e=>{resume(); if(gameOver)return; 
                if(e.key==='a'||e.key==='ArrowLeft')movePlayer(-1); if(e.key==='d'||e.key==='ArrowRight')movePlayer(1);
                if(e.key==='w'||e.key==='ArrowUp')isAccelerating=true; if(e.key==='s'||e.key==='ArrowDown')isBraking=true;
            });
            window.addEventListener('keyup', e=>{
                if(e.key==='w'||e.key==='ArrowUp')isAccelerating=false; if(e.key==='s'||e.key==='ArrowDown')isBraking=false;
            });
            restartButton.addEventListener('click', ()=>{resume(); resetGame();});
            window.addEventListener('touchstart', e=>{resume(); if(e.target.closest('button'))return; touchStartX=e.touches[0].clientX; if(touchStartX>window.innerWidth/2)isAccelerating=true; else isBraking=true;}, {passive:false});
            window.addEventListener('touchend', e=>{if(gameOver)return; const d=e.changedTouches[0].clientX-touchStartX; if(Math.abs(d)>30)movePlayer(d>0?1:-1); isAccelerating=false; isBraking=false;});
        }
        
        init();
    </script>
</body>
</html>