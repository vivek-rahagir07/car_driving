<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>City Driving</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            /* Prevent scrolling and pull-to-refresh on mobile */
            touch-action: none;
            background-color: #111827; /* Fallback color */
        }

        #gameCanvas {
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            margin: 0 auto;
        }

        .game-button {
            display: inline-block;
            background-image: linear-gradient(to right, #3b82f6, #2563eb);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.2s ease-in-out;
            border: none;
            cursor: pointer;
            user-select: none;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-image: linear-gradient(to right, #2563eb, #3b82f6);
        }

        /* Mobile Controls Overlay */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 180px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 20;
        }

        .control-section {
            display: flex;
            align-items: flex-end;
            pointer-events: auto;
        }

        #steeringContainer {
            width: 160px;
            height: 160px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #steeringWheel {
            width: 100%;
            height: 100%;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='48' fill='none' stroke='%23333' stroke-width='4'/%3E%3Ccircle cx='50' cy='50' r='44' fill='%231a1a1a' stroke='%23555' stroke-width='2'/%3E%3Cpath d='M50 50 L50 6' stroke='%23333' stroke-width='8'/%3E%3Cpath d='M50 50 L10 70' stroke='%23333' stroke-width='8'/%3E%3Cpath d='M50 50 L90 70' stroke='%23333' stroke-width='8'/%3E%3Ccircle cx='50' cy='50' r='10' fill='%23333'/%3E%3Ccircle cx='50' cy='50' r='4' fill='%23555'/%3E%3Cpath d='M48 6 L52 6' stroke='red' stroke-width='4'/%3E%3C/svg%3E") no-repeat center center;
            background-size: contain;
            transition: transform 0.1s ease-out;
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.5));
        }

        .pedal-group {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .pedal {
            position: relative;
            transition: transform 0.1s;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.4));
            cursor: pointer;
        }

        .pedal:active,
        .pedal.active {
            transform: scale(0.95) translateY(2px);
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.4));
        }

        #btnBrake {
            width: 80px;
            height: 60px;
            background: linear-gradient(180deg, #555, #333);
            border-radius: 8px;
            border: 2px solid #777;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #btnBrake::after {
            content: '';
            width: 70%;
            height: 4px;
            background: #222;
            box-shadow: 0 10px 0 #222, 0 20px 0 #222;
        }

        #btnGas {
            width: 60px;
            height: 120px;
            background: linear-gradient(180deg, #333, #111);
            border-radius: 8px;
            border: 2px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #btnGas::after {
            content: '';
            width: 4px;
            height: 80%;
            background: #222;
            box-shadow: 10px 0 0 #222, -10px 0 0 #222;
        }

        @media (max-width: 768px) {
            .desktop-hint {
                display: none;
            }
        }
    </style>
</head>

<body class="bg-gray-900 min-h-screen flex flex-col items-center justify-center text-white p-4">

    <h1 class="text-4xl md:text-5xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-blue-600 select-none">
        City Driving
    </h1>

    <div class="mb-2 flex gap-6 text-xl font-medium select-none">
        <div>Score: <span id="score" class="font-bold text-yellow-300">0</span></div>
        <div>Speed: <span id="speedDisplay" class="font-bold text-cyan-300">1.0x</span></div>
        <div id="comboDisplay" class="font-bold text-green-400 hidden">Combo: <span id="comboValue">0</span>x</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Mobile Controls Overlay -->
    <div id="mobileControls" class="md:hidden">
        <div class="control-section">
            <div id="steeringContainer">
                <div id="steeringWheel"></div>
            </div>
        </div>

        <div class="control-section pedal-group">
            <div id="btnBrake" class="pedal" title="Brake"></div>
            <div id="btnGas" class="pedal" title="Accelerate"></div>
        </div>
    </div>

    <p class="mt-4 text-gray-400 text-sm md:text-base text-center desktop-hint select-none">
        Keys: Left/Right or A/D (Move), Up/W (Race), Down/S (Brake)
    </p>

    <div id="gameOverModal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white text-gray-900 p-8 md:p-12 rounded-lg shadow-2xl text-center transform scale-90 transition-all">
            <h2 class="text-3xl font-bold mb-4">Game Over!</h2>
            <p class="text-xl mb-2">
                Final Score: <span id="finalScore" class="font-bold text-blue-600">0</span>
            </p>
            <p class="text-lg mb-6">
                Max Combo: <span id="finalCombo" class="font-bold text-green-600">0</span>x
            </p>
            <button id="restartButton" class="game-button">
                Play Again
            </button>
        </div>
    </div>

    <script type="module">
        // --- DOM Element Selection ---
        const canvas = document.getElementById('gameCanvas');
        const scoreEl = document.getElementById('score');
        const speedDisplayEl = document.getElementById('speedDisplay');
        const comboDisplayEl = document.getElementById('comboDisplay');
        const comboValueEl = document.getElementById('comboValue');
        const modalEl = document.getElementById('gameOverModal');
        const finalScoreEl = document.getElementById('finalScore');
        const finalComboEl = document.getElementById('finalCombo');
        const restartButton = document.getElementById('restartButton');
        const steeringContainer = document.getElementById('steeringContainer');
        const steeringWheel = document.getElementById('steeringWheel');
        const btnGas = document.getElementById('btnGas');
        const btnBrake = document.getElementById('btnBrake');

        // --- Game Constants ---
        const LANE_COUNT = 3;
        const LANE_WIDTH = 5;
        const ROAD_WIDTH = LANE_COUNT * LANE_WIDTH;
        const ROAD_LENGTH = 100;
        const CAR_BODY_WIDTH = 2.5;
        const CAR_BODY_HEIGHT = 1.0;
        const CAR_BODY_DEPTH = 4.5;
        const WHEEL_RADIUS = 0.5;
        const WHEEL_THICKNESS = 0.3;
        const PLAYER_Z_POSITION = 15;
        const SPAWN_Z_POSITION = -ROAD_LENGTH * 1.5;
        const DESPAWN_Z_POSITION = PLAYER_Z_POSITION + 20;
        
        // Touch Constants
        const SWIPE_THRESHOLD = 30;

        // --- Colors ---
        const PLAYER_COLOR = 0x3b82f6;
        const ENEMY_COLORS = [0xef4444, 0xf97316, 0xeab308, 0x8b5cf6, 0xec4899, 0x10b981, 0x6b7280];
        const AMBULANCE_LIGHT_COLOR = 0xef4444;
        const GREEN_LIGHT_COLOR = 0x22c55e;
        const RED_LIGHT_COLOR = 0xef4444;
        const ROAD_COLOR = 0x34495e;
        const LINE_COLOR = 0xffffff;
        const TREE_TRUNK_COLOR = 0x5d4037;
        const TREE_LEAVES_COLOR = 0x2e7d32;
        const BUILDING_COLORS = [0x374151, 0x4b5563, 0x1f2937, 0x111827];
        const STREET_LIGHT_POLE_COLOR = 0x6b7280;
        const STREET_LIGHT_BULB_COLOR = 0xfef08a;
        const COIN_COLOR = 0xffd700;

        // --- State Variables ---
        let scene, camera, renderer;
        let playerCar, road;
        let roadLines = [];
        let enemies = [], ambulances = [], trafficLights = [], scenery = [], coins = [];
        let particles = [];
        
        let score = 0;
        let gameSpeed = 0.3;
        let gameOver = false;
        let animationFrameId;
        
        let playerLane = 1;
        let playerTargetX = 0;
        let isAccelerating = false;
        let isBraking = false;
        let combo = 0;
        let maxCombo = 0;
        let comboTimer = 0;

        let lastSpawnZ = SPAWN_Z_POSITION;
        
        let CANVAS_WIDTH, CANVAS_HEIGHT;
        
        // Input Vars
        let tiltEnabled = false;
        let currentTilt = 0;
        let hasTriggeredTurn = false;
        let touchStartX = 0;
        let touchEndX = 0;

        // --- Utility Functions ---
        function random(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function randomFloat(min, max) { return Math.random() * (max - min) + min; }
        function laneToX(lane) { return (lane - (LANE_COUNT - 1) / 2) * LANE_WIDTH; }

        // --- Init & Reset ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e293b); // Darker night/evening sky
            scene.fog = new THREE.Fog(0x1e293b, 40, 130);

            updateCanvasSize();
            camera = new THREE.PerspectiveCamera(75, CANVAS_WIDTH / CANVAS_HEIGHT, 0.1, 1000);
            camera.position.set(0, 8, PLAYER_Z_POSITION + 7);
            camera.lookAt(0, 0, PLAYER_Z_POSITION - 10);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
            renderer.shadowMap.enabled = true;

            // Lights
            const ambientLight = new THREE.HemisphereLight(0x4b5563, 0x111827, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(-10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            scene.add(dirLight);

            // Road
            const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH * 3);
            const roadMaterial = new THREE.MeshStandardMaterial({ color: ROAD_COLOR, roughness: 0.8, metalness: 0.1 });
            road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.z = -ROAD_LENGTH / 2 + PLAYER_Z_POSITION;
            road.receiveShadow = true;
            scene.add(road);

            // Sidewalks
            const sidewalkGeom = new THREE.PlaneGeometry(5, ROAD_LENGTH * 3);
            const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x9ca3af });
            
            const leftWalk = new THREE.Mesh(sidewalkGeom, sidewalkMat);
            leftWalk.rotation.x = -Math.PI / 2;
            leftWalk.position.set(-ROAD_WIDTH/2 - 2.5, 0.02, road.position.z);
            leftWalk.receiveShadow = true;
            scene.add(leftWalk);
            
            const rightWalk = new THREE.Mesh(sidewalkGeom, sidewalkMat);
            rightWalk.rotation.x = -Math.PI / 2;
            rightWalk.position.set(ROAD_WIDTH/2 + 2.5, 0.02, road.position.z);
            rightWalk.receiveShadow = true;
            scene.add(rightWalk);

            // Lines
            const lineMat = new THREE.MeshStandardMaterial({ color: LINE_COLOR, roughness: 0.5 });
            const lineGeom = new THREE.PlaneGeometry(0.3, 4);
            const lineGap = 8;
            for (let i = 1; i < LANE_COUNT; i++) {
                const lineX = laneToX(i - 1) + LANE_WIDTH / 2;
                for (let z = -ROAD_LENGTH * 2; z < ROAD_LENGTH * 2; z += lineGap) {
                    const line = new THREE.Mesh(lineGeom, lineMat);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(lineX, 0.03, z);
                    scene.add(line);
                    roadLines.push(line);
                }
            }

            addEventListeners();
            resetGame();
        }

        function resetGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            score = 0;
            gameSpeed = 0.3;
            gameOver = false;
            isAccelerating = false;
            isBraking = false;
            combo = 0;
            maxCombo = 0;
            comboTimer = 0;
            lastSpawnZ = SPAWN_Z_POSITION;

            // Cleanup
            if (playerCar) scene.remove(playerCar);
            [...enemies, ...ambulances, ...trafficLights].forEach(obj => scene.remove(obj.mesh));
            scenery.forEach(obj => scene.remove(obj.mesh));
            coins.forEach(obj => scene.remove(obj.mesh));
            particles.forEach(p => scene.remove(p));

            enemies = []; ambulances = []; trafficLights = []; scenery = []; coins = []; particles = [];

            // Pre-spawn scenery
            for (let z = PLAYER_Z_POSITION; z > SPAWN_Z_POSITION * 1.5; z -= 15) {
                spawnSceneryRow(z);
            }

            // Player Setup
            playerCar = createCar(PLAYER_COLOR, true);
            playerLane = 1;
            playerTargetX = laneToX(playerLane);
            playerCar.position.set(playerTargetX, 0, PLAYER_Z_POSITION);
            scene.add(playerCar);

            // UI Reset
            scoreEl.textContent = score;
            speedDisplayEl.textContent = '1.0x';
            comboDisplayEl.classList.add('hidden');
            modalEl.classList.add('hidden');
            
            animate();
        }

        // --- Object Creators ---
        function createCar(color, isPlayer = false) {
            const car = new THREE.Group();
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.2 });

            // Chassis
            const chassisHeight = CAR_BODY_HEIGHT * 0.8;
            const chassisGeom = new THREE.BoxGeometry(CAR_BODY_WIDTH, chassisHeight, CAR_BODY_DEPTH);
            const chassis = new THREE.Mesh(chassisGeom, bodyMat);
            chassis.position.y = WHEEL_RADIUS + chassisHeight / 2;
            chassis.castShadow = true;
            chassis.receiveShadow = true;
            car.add(chassis);

            // Cabin
            const cabinHeight = CAR_BODY_HEIGHT * 0.7;
            const cabinWidth = CAR_BODY_WIDTH * 0.7;
            const cabinDepth = CAR_BODY_DEPTH * 0.35;
            const cabinMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.1 });
            const cabinGeom = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinDepth);
            const cabin = new THREE.Mesh(cabinGeom, cabinMat);
            cabin.position.set(0, chassis.position.y + chassisHeight / 2 + cabinHeight / 2 - 0.1, isPlayer ? 0.5 : -0.5);
            cabin.castShadow = true;
            car.add(cabin);

            // Headlights
            if (isPlayer) {
                const headLightGeom = new THREE.BoxGeometry(0.5, 0.2, 0.1);
                const headLightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2 });
                const hlLeft = new THREE.Mesh(headLightGeom, headLightMat);
                hlLeft.position.set(-0.8, chassis.position.y + 0.1, -CAR_BODY_DEPTH/2 - 0.05);
                car.add(hlLeft);
                const hlRight = new THREE.Mesh(headLightGeom, headLightMat);
                hlRight.position.set(0.8, chassis.position.y + 0.1, -CAR_BODY_DEPTH/2 - 0.05);
                car.add(hlRight);
                
                // Spotlights for night driving feel
                const spotL = new THREE.SpotLight(0xffffff, 2, 40, 0.5, 0.5, 1);
                spotL.position.set(-0.8, chassis.position.y + 0.1, -CAR_BODY_DEPTH/2);
                spotL.target.position.set(-0.8, 0, -20);
                car.add(spotL);
                car.add(spotL.target);
                
                const spotR = new THREE.SpotLight(0xffffff, 2, 40, 0.5, 0.5, 1);
                spotR.position.set(0.8, chassis.position.y + 0.1, -CAR_BODY_DEPTH/2);
                spotR.target.position.set(0.8, 0, -20);
                car.add(spotR);
                car.add(spotR.target);
            } else {
                 // Taillights for enemies
                const tailLightGeom = new THREE.BoxGeometry(0.5, 0.2, 0.1);
                const tailLightMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1 });
                const tlLeft = new THREE.Mesh(tailLightGeom, tailLightMat);
                tlLeft.position.set(-0.8, chassis.position.y + 0.2, CAR_BODY_DEPTH/2 + 0.05);
                car.add(tlLeft);
                const tlRight = new THREE.Mesh(tailLightGeom, tailLightMat);
                tlRight.position.set(0.8, chassis.position.y + 0.2, CAR_BODY_DEPTH/2 + 0.05);
                car.add(tlRight);
            }

            // Wheels
            const wheelGeom = new THREE.CylinderGeometry(WHEEL_RADIUS, WHEEL_RADIUS, WHEEL_THICKNESS, 16);
            wheelGeom.rotateZ(Math.PI / 2);
            [
                { x: -1, z: 0.7 }, { x: 1, z: 0.7 }, { x: -1, z: -0.7 }, { x: 1, z: -0.7 }
            ].forEach(offset => {
                const w = new THREE.Mesh(wheelGeom, wheelMat);
                w.position.set(offset.x * (CAR_BODY_WIDTH / 2), WHEEL_RADIUS, offset.z * (CAR_BODY_DEPTH / 2));
                w.castShadow = true;
                car.add(w);
            });

            car.userData.box = new THREE.Box3().setFromObject(chassis);
            return car;
        }

        function createTree() {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeom = new THREE.CylinderGeometry(0.4, 0.5, 2, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: TREE_TRUNK_COLOR });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 1;
            trunk.castShadow = true;
            group.add(trunk);
            
            // Leaves
            const leavesGeom = new THREE.DodecahedronGeometry(1.5);
            const leavesMat = new THREE.MeshStandardMaterial({ color: TREE_LEAVES_COLOR });
            const leaves = new THREE.Mesh(leavesGeom, leavesMat);
            leaves.position.y = 2.8;
            leaves.castShadow = true;
            group.add(leaves);
            
            return group;
        }

        function createBuilding() {
            const height = randomFloat(8, 20);
            const width = randomFloat(5, 10);
            const depth = randomFloat(5, 10);
            const color = BUILDING_COLORS[random(0, BUILDING_COLORS.length-1)];
            
            const geom = new THREE.BoxGeometry(width, height, depth);
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.9 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.y = height / 2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Simple windows (emissive dots)
            if (Math.random() > 0.3) {
                 const winGeom = new THREE.PlaneGeometry(0.5, 0.5);
                 const winMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
                 for(let y = 2; y < height - 1; y += 2) {
                     for(let x = -width/2 + 1; x < width/2; x+=2) {
                         if(Math.random() > 0.4) {
                             const win = new THREE.Mesh(winGeom, winMat);
                             win.position.set(x, y, depth/2 + 0.05);
                             mesh.add(win);
                         }
                     }
                 }
            }
            
            return mesh;
        }

        function createStreetLight() {
            const group = new THREE.Group();
            
            // Pole
            const poleGeom = new THREE.CylinderGeometry(0.1, 0.1, 8, 6);
            const poleMat = new THREE.MeshStandardMaterial({ color: STREET_LIGHT_POLE_COLOR });
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.y = 4;
            pole.castShadow = true;
            group.add(pole);
            
            // Arm
            const armGeom = new THREE.BoxGeometry(2, 0.1, 0.1);
            const arm = new THREE.Mesh(armGeom, poleMat);
            arm.position.set(0.8, 7.8, 0);
            group.add(arm);
            
            // Bulb Mesh
            const bulbGeom = new THREE.BoxGeometry(0.5, 0.1, 0.3);
            const bulbMat = new THREE.MeshStandardMaterial({ color: STREET_LIGHT_BULB_COLOR, emissive: STREET_LIGHT_BULB_COLOR, emissiveIntensity: 2 });
            const bulb = new THREE.Mesh(bulbGeom, bulbMat);
            bulb.position.set(1.5, 7.7, 0);
            group.add(bulb);
            
            // Actual Light
            const spot = new THREE.SpotLight(0xffaa00, 1.5, 15, 0.8, 0.5, 1);
            spot.position.set(1.5, 7.5, 0);
            spot.target.position.set(1.5, 0, 0);
            group.add(spot);
            group.add(spot.target);
            
            return group;
        }

        function createAmbulance() {
            const ambu = createCar(0xffffff);
            const lightGeom = new THREE.BoxGeometry(0.5, 0.3, 0.5);
            const lightMat = new THREE.MeshStandardMaterial({ color: AMBULANCE_LIGHT_COLOR, emissive: AMBULANCE_LIGHT_COLOR, emissiveIntensity: 2 });
            const light = new THREE.Mesh(lightGeom, lightMat);
            light.position.y = 2.2; 
            ambu.add(light);
            ambu.userData.flashingLight = light;
            ambu.userData.isAmbulance = true;
            return ambu;
        }

        function createTrafficLight(type) {
            const group = new THREE.Group();
            const color = (type === 'GREEN') ? GREEN_LIGHT_COLOR : RED_LIGHT_COLOR;
            const geom = new THREE.CylinderGeometry(LANE_WIDTH * 0.4, LANE_WIDTH * 0.4, 0.2, 16);
            const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 2 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.rotation.x = Math.PI / 2;
            mesh.position.y = 0.5;
            group.add(mesh);
            
            // Halo
            const ringGeom = new THREE.RingGeometry(LANE_WIDTH * 0.4, LANE_WIDTH * 0.5, 16);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            group.add(ring);

            group.userData.box = new THREE.Box3().setFromObject(mesh);
            group.userData.type = type;
            return group;
        }

        function createCoin() {
            const coinGeom = new THREE.CylinderGeometry(0.7, 0.7, 0.1, 16);
            const coinMat = new THREE.MeshStandardMaterial({ color: COIN_COLOR, metalness: 1, roughness: 0.2, emissive: 0xaa8800, emissiveIntensity: 0.4 });
            const coin = new THREE.Mesh(coinGeom, coinMat);
            coin.rotation.x = Math.PI / 2;
            
            const group = new THREE.Group();
            group.add(coin);
            group.userData.box = new THREE.Box3().setFromObject(coin);
            return group;
        }

        function createParticle(pos, color) {
            const geom = new THREE.SphereGeometry(0.2, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const p = new THREE.Mesh(geom, mat);
            p.position.copy(pos);
            p.userData.vel = new THREE.Vector3(randomFloat(-1, 1), randomFloat(1, 3), randomFloat(-1, 1));
            p.userData.life = 1.0;
            scene.add(p);
            particles.push(p);
        }

        // --- Updates ---
        function updatePlayer() {
            playerCar.position.x += (playerTargetX - playerCar.position.x) * 0.15;
            playerCar.rotation.z = (playerTargetX - playerCar.position.x) * -0.05; // Tilt
            playerCar.userData.box.setFromObject(playerCar.children[0]);
        }

        function updateRoadLines(speed) {
            roadLines.forEach(line => {
                line.position.z += speed;
                if (line.position.z > DESPAWN_Z_POSITION) line.position.z -= ROAD_LENGTH * 4;
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.1; // Gravity
                p.userData.life -= 0.03;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        function updateGameObjects(speed) {
            // Combo timer
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer === 0) {
                    combo = 0;
                    comboDisplayEl.classList.add('hidden');
                }
            }

            // Scenery
            for (let i = scenery.length - 1; i >= 0; i--) {
                let s = scenery[i];
                s.mesh.position.z += speed;
                if (s.mesh.position.z > DESPAWN_Z_POSITION) {
                    scene.remove(s.mesh);
                    scenery.splice(i, 1);
                }
            }

            // Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                e.mesh.position.z += speed;
                e.mesh.userData.box.setFromObject(e.mesh.children[0]);

                if (checkCollision(playerCar, e.mesh)) return endGame();

                if (e.mesh.position.z > DESPAWN_Z_POSITION) {
                    // Score & Near Miss
                    score += 10;
                    scene.remove(e.mesh);
                    enemies.splice(i, 1);
                }
            }

            // Ambulances
            for (let i = ambulances.length - 1; i >= 0; i--) {
                let a = ambulances[i];
                a.mesh.position.z += speed * 1.5;
                a.mesh.userData.box.setFromObject(a.mesh.children[0]);
                a.mesh.userData.flashingLight.visible = Math.floor(Date.now() / 150) % 2 === 0;

                if (checkCollision(playerCar, a.mesh)) return endGame();
                if (a.mesh.position.z > DESPAWN_Z_POSITION) {
                    scene.remove(a.mesh);
                    ambulances.splice(i, 1);
                }
            }

            // Traffic Lights
            for (let i = trafficLights.length - 1; i >= 0; i--) {
                let t = trafficLights[i];
                t.mesh.position.z += speed;
                t.mesh.userData.box.setFromObject(t.mesh.children[0]);

                if (checkCollision(playerCar, t.mesh)) {
                    if (t.type === 'GREEN') {
                        score += 50;
                        combo++;
                        comboTimer = 180;
                        comboDisplayEl.classList.remove('hidden');
                        comboValueEl.textContent = combo;
                        scene.remove(t.mesh);
                        trafficLights.splice(i, 1);
                        spawnExplosion(t.mesh.position, GREEN_LIGHT_COLOR, 5);
                    } else {
                        return endGame();
                    }
                } else if (t.mesh.position.z > DESPAWN_Z_POSITION) {
                    scene.remove(t.mesh);
                    trafficLights.splice(i, 1);
                }
            }

            // Coins
            for (let i = coins.length - 1; i >= 0; i--) {
                let c = coins[i];
                c.mesh.position.z += speed;
                c.mesh.rotation.y += 0.1;
                c.mesh.userData.box.setFromObject(c.mesh.children[0]);

                if (checkCollision(playerCar, c.mesh)) {
                    score += 25;
                    spawnExplosion(c.mesh.position, COIN_COLOR, 4);
                    scene.remove(c.mesh);
                    coins.splice(i, 1);
                } else if (c.mesh.position.z > DESPAWN_Z_POSITION) {
                    scene.remove(c.mesh);
                    coins.splice(i, 1);
                }
            }
        }

        function checkCollision(a, b) {
            return a.userData.box && b.userData.box && a.userData.box.intersectsBox(b.userData.box);
        }

        function spawnExplosion(pos, color, count) {
            for (let i = 0; i < count; i++) createParticle(pos, color);
        }

        // --- Spawning Logic ---
        function spawnSceneryRow(zPos) {
             // Left Side
             if (Math.random() > 0.3) {
                 const type = Math.random();
                 let mesh;
                 let xPos = -ROAD_WIDTH/2 - 5 - randomFloat(0, 5);
                 
                 if (type < 0.2) { // Streetlight
                     mesh = createStreetLight();
                     xPos = -ROAD_WIDTH/2 - 2.5; // Closer to road
                     mesh.rotation.y = -Math.PI / 2; // Face road
                 } else if (type < 0.6) { // Tree
                     mesh = createTree();
                 } else { // Building
                     mesh = createBuilding();
                     xPos -= 10; // Further back
                 }
                 mesh.position.set(xPos, 0, zPos);
                 scene.add(mesh);
                 scenery.push({ mesh });
             }
             
             // Right Side
             if (Math.random() > 0.3) {
                 const type = Math.random();
                 let mesh;
                 let xPos = ROAD_WIDTH/2 + 5 + randomFloat(0, 5);
                 
                 if (type < 0.2) { // Streetlight
                     mesh = createStreetLight();
                     xPos = ROAD_WIDTH/2 + 2.5;
                     mesh.rotation.y = Math.PI / 2; // Face road
                 } else if (type < 0.6) { // Tree
                     mesh = createTree();
                 } else { // Building
                     mesh = createBuilding();
                     xPos += 10;
                 }
                 mesh.position.set(xPos, 0, zPos);
                 scene.add(mesh);
                 scenery.push({ mesh });
             }
        }

        function spawnObjects() {
            // Spawn Scenery regularly based on distance traveled approximation
            if (lastSpawnZ > SPAWN_Z_POSITION + 15) { 
                // Using frames/speed to approx distance is tricky with variable speed.
                // Instead, we just spawn randomly each frame but check logic
            }
            
            // Just reuse spawn timer logic or random check
            if (Math.random() < 0.05 + gameSpeed * 0.02) {
                // Determine Z position based on the "furthest back" object to prevent gaps?
                // For simplicity in this runner style, we spawn at fixed distance relative to world
                // But since world moves (objects move +z), we spawn at fixed negative Z.
                spawnSceneryRow(SPAWN_Z_POSITION);
            }

            // Enemies
            if (Math.random() < 0.01 + gameSpeed * 0.01) {
                const lane = random(0, LANE_COUNT - 1);
                if (isLaneClear(lane)) {
                    const mesh = createCar(ENEMY_COLORS[random(0, ENEMY_COLORS.length - 1)]);
                    mesh.position.set(laneToX(lane), 0, SPAWN_Z_POSITION);
                    enemies.push({ mesh, lane });
                    scene.add(mesh);
                    lastSpawnZ = SPAWN_Z_POSITION;
                }
            }

            // Ambulances
            if (Math.random() < 0.002) {
                const lane = random(0, LANE_COUNT - 1);
                if (isLaneClear(lane)) {
                    const mesh = createAmbulance();
                    mesh.position.set(laneToX(lane), 0, SPAWN_Z_POSITION);
                    ambulances.push({ mesh, lane });
                    scene.add(mesh);
                    lastSpawnZ = SPAWN_Z_POSITION;
                }
            }

            // Lights
            if (Math.random() < 0.005) {
                const lane = random(0, LANE_COUNT - 1);
                if (isLaneClear(lane)) {
                    const type = Math.random() > 0.4 ? 'GREEN' : 'RED';
                    const mesh = createTrafficLight(type);
                    mesh.position.set(laneToX(lane), 0, SPAWN_Z_POSITION);
                    trafficLights.push({ mesh, lane, type });
                    scene.add(mesh);
                    lastSpawnZ = SPAWN_Z_POSITION;
                }
            }

            // Coins
            if (Math.random() < 0.01) {
                const lane = random(0, LANE_COUNT - 1);
                if (isLaneClear(lane)) {
                    for(let k=0; k<5; k++) {
                        const mesh = createCoin();
                        mesh.position.set(laneToX(lane), 1, SPAWN_Z_POSITION - (k * 4));
                        coins.push({ mesh, lane });
                        scene.add(mesh);
                    }
                }
            }
        }

        function isLaneClear(lane) {
            const allObjs = [...enemies, ...ambulances, ...trafficLights];
            return allObjs.every(o => o.lane !== lane || o.mesh.position.z > lastSpawnZ + 30);
        }

        function endGame() {
            if (gameOver) return;
            gameOver = true;
            cancelAnimationFrame(animationFrameId);
            
            spawnExplosion(playerCar.position, 0xff5500, 30);
            scene.remove(playerCar);
            updateParticles(); // One last update for explosion

            finalScoreEl.textContent = score;
            finalComboEl.textContent = maxCombo;
            modalEl.classList.remove('hidden');
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            if (!gameOver) {
                let speedMult = isAccelerating ? 2.0 : (isBraking ? 0.5 : 1.0);
                let currentSpeed = gameSpeed * speedMult;

                updatePlayer();
                updateRoadLines(currentSpeed);
                updateGameObjects(currentSpeed);
                updateParticles();
                spawnObjects();

                // UI Updates
                scoreEl.textContent = score;
                speedDisplayEl.textContent = (currentSpeed * 3).toFixed(1) + 'x';
                gameSpeed = Math.min(gameSpeed + 0.0001, 1.0); // Slow accel
                
                // Dynamic FOV
                const targetFOV = isAccelerating ? 85 : 75;
                camera.fov += (targetFOV - camera.fov) * 0.05;
                camera.updateProjectionMatrix();

                renderer.render(scene, camera);
            } else {
                 renderer.render(scene, camera);
            }
        }

        // --- Controls ---
        function movePlayer(dir) {
            playerLane = Math.max(0, Math.min(LANE_COUNT - 1, playerLane + dir));
            playerTargetX = laneToX(playerLane);
        }

        function updateCanvasSize() {
             if (window.innerWidth < 768 && window.innerHeight > window.innerWidth) {
                CANVAS_WIDTH = Math.min(600, window.innerWidth * 0.95);
                CANVAS_HEIGHT = Math.min(500, window.innerHeight * 0.5);
            } else {
                CANVAS_WIDTH = Math.min(600, window.innerWidth * 0.9);
                CANVAS_HEIGHT = Math.min(600, window.innerHeight * 0.6);
            }
            if(canvas) { canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT; }
            if(camera) { camera.aspect = CANVAS_WIDTH / CANVAS_HEIGHT; camera.updateProjectionMatrix(); }
            if(renderer) { renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT); }
        }

        function addEventListeners() {
            window.addEventListener('resize', updateCanvasSize);
            window.addEventListener('keydown', e => {
                if(gameOver) return;
                if(e.key === 'ArrowLeft' || e.key === 'a') movePlayer(-1);
                if(e.key === 'ArrowRight' || e.key === 'd') movePlayer(1);
                if(e.key === 'ArrowUp' || e.key === 'w') isAccelerating = true;
                if(e.key === 'ArrowDown' || e.key === 's') isBraking = true;
            });
            window.addEventListener('keyup', e => {
                if(e.key === 'ArrowUp' || e.key === 'w') isAccelerating = false;
                if(e.key === 'ArrowDown' || e.key === 's') isBraking = false;
            });

            // Touch
            const handleBtn = (el, start, end) => {
                if(!el) return;
                el.addEventListener('touchstart', e => { e.preventDefault(); start(); el.classList.add('active'); }, {passive:false});
                el.addEventListener('touchend', e => { e.preventDefault(); end(); el.classList.remove('active'); });
                el.addEventListener('mousedown', e => { start(); el.classList.add('active'); });
                el.addEventListener('mouseup', e => { end(); el.classList.remove('active'); });
                el.addEventListener('mouseleave', e => { end(); el.classList.remove('active'); });
            };
            handleBtn(btnGas, () => isAccelerating = true, () => isAccelerating = false);
            handleBtn(btnBrake, () => isBraking = true, () => isBraking = false);
            restartButton.addEventListener('click', resetGame);

            // Swipe
            window.addEventListener('touchstart', e => {
                if (e.target.closest('#mobileControls')) return;
                touchStartX = e.touches[0].clientX;
            }, {passive:false});
            
            window.addEventListener('touchend', e => {
                if (gameOver || touchStartX === 0) return;
                touchEndX = e.changedTouches[0].clientX;
                const diff = touchEndX - touchStartX;
                if (Math.abs(diff) > SWIPE_THRESHOLD) {
                    movePlayer(diff > 0 ? 1 : -1);
                }
                touchStartX = 0;
            });
            
            // Tilt Hint
            if(steeringContainer) {
                const hint = document.createElement('div');
                hint.innerText = "TAP TO ENABLE TILT";
                hint.style.cssText = "position:absolute; width:100%; text-align:center; font-size:10px; font-weight:bold; color:white; pointer-events:none;";
                steeringContainer.appendChild(hint);
                
                steeringContainer.addEventListener('click', async () => {
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try {
                            const resp = await DeviceOrientationEvent.requestPermission();
                            if(resp === 'granted') enableTilt(hint);
                        } catch(e) { console.error(e); }
                    } else {
                        enableTilt(hint);
                    }
                });
            }
        }

        function enableTilt(hintEl) {
            tiltEnabled = true;
            if(hintEl) hintEl.style.display = 'none';
            window.addEventListener('deviceorientation', e => {
                if(!tiltEnabled || !e.gamma) return;
                const angle = Math.max(-90, Math.min(90, e.gamma));
                if(steeringWheel) steeringWheel.style.transform = `rotate(${angle}deg)`;
                
                if(!hasTriggeredTurn) {
                    if(angle < -15) { movePlayer(-1); hasTriggeredTurn = true; }
                    else if(angle > 15) { movePlayer(1); hasTriggeredTurn = true; }
                } else if(Math.abs(angle) < 5) {
                    hasTriggeredTurn = false;
                }
            });
        }
        
        // Start
        init();
    </script>
</body>
</html>