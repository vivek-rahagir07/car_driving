<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Neon Drive: Night City</title>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">

<style>
/* GLOBAL THEME */
:root {
    --neon-blue: #00f3ff;
    --neon-pink: #bc13fe;
    --neon-green: #0aff0a;
    --neon-red: #ff003c;
    --ui-bg: rgba(5, 10, 20, 0.85);
}

body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #050510;
    font-family: 'Orbitron', sans-serif;
    color: white;
    width: 100vw;
    height: 100vh;
    user-select: none;
}

/* CANVAS */
#gameCanvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

/* CRT EFFECTS */
.scanlines {
    position: fixed;
    inset: 0;
    background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%);
    background-size: 100% 4px;
    opacity: 0.6;
    z-index: 50;
    pointer-events: none;
}
.vignette {
    position: fixed;
    inset: 0;
    background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
    z-index: 49;
    pointer-events: none;
}

/* HYPER MODE SCREEN OVERLAY */
.hyper-overlay {
    position: fixed;
    inset: 0;
    background: transparent;
    box-shadow: inset 0 0 100px var(--neon-blue);
    opacity: 0;
    pointer-events: none;
    z-index: 48;
    transition: opacity .5s;
}
.hyper-active .hyper-overlay {
    opacity: 1;
    animation: pulseHyper .5s infinite alternate;
}
@keyframes pulseHyper {
    from { box-shadow: inset 0 0 50px var(--neon-blue); }
    to   { box-shadow: inset 0 0 150px var(--neon-pink); }
}

/* UI LAYER */
#ui-layer {
    position: absolute;
    inset: 0;
    z-index: 10;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    pointer-events: none;
    padding: 20px;
    box-sizing: border-box;
}

/* HUD BOXES */
.hud-header {
    display: flex;
    justify-content: space-between;
}
.hud-box {
    background: var(--ui-bg);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,.1);
    padding: 10px 24px;
    transform: skewX(-15deg);
    min-width: 140px;
    position: relative;
    box-shadow: 0 0 15px rgba(0,243,255,0.1);
}
.hud-box::before {
    content: "";
    position: absolute;
    top: 0; left: 0;
    height: 100%; width: 4px;
    background: var(--neon-blue);
    box-shadow: 0 0 10px var(--neon-blue);
}
.hud-box.right-align::before {
    left: auto; right: 0;
    background: var(--neon-pink);
    box-shadow: 0 0 10px var(--neon-pink);
}
.hud-content { transform: skewX(15deg); text-align: center; }

/* LABELS */
.label {
    font-family: 'Rajdhani', sans-serif;
    font-size: .8rem;
    text-transform: uppercase;
    color: #8fa1b3;
    letter-spacing: 2px;
}
.value {
    font-size: 1.8rem;
    font-weight: 700;
    text-shadow: 0 0 10px rgba(255,255,255,.5);
}

/* SPEED + ENERGY BARS */
.bar-container {
    background: rgba(255,255,255,0.1);
    width: 100%;
    height: 4px;
    overflow: hidden;
}
.speed-bar-fill {
    height: 100%;
    width: 0%;
    transition: width .1s linear;
    background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink));
}
.energy-bar-fill {
    height: 100%;
    width: 0%;
    transition: width .2s ease-out;
    background: linear-gradient(90deg, var(--neon-green), var(--neon-blue));
}

/* HYPER MODE SUBTEXT */
.hyper-text {
    display: none;
    font-size: .7rem;
    color: var(--neon-green);
    font-weight: 900;
}
.hyper-active .hyper-text { display: block; }

/* POWERUP BADGES */
.status-badge {
    background: rgba(0,0,0,.9);
    padding: 10px 20px;
    display: flex;
    gap: 12px;
    align-items: center;
    color: white;
    border-right: 4px solid #fff;
    clip-path: polygon(15px 0,100% 0,100% 100%,0 100%);
    transform: translateX(150%);
    transition: .4s;
}
.status-active { transform: translateX(0); }
.shield-active { color: var(--neon-blue); border-color: var(--neon-blue); }
.magnet-active { color: var(--neon-red); border-color: var(--neon-red); }
.nitro-active  { color: var(--neon-pink); border-color: var(--neon-pink); }

/* START SCREEN */
#startScreen {
    position: fixed;
    inset: 0;
    background: rgba(5,5,10,.98);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
    opacity: 1;
    visibility: visible;
    transition: .5s;
}
#startScreen.fade-out {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
}

.title-glitch {
    font-size: 5rem;
    font-weight: 900;
    text-transform: uppercase;
    text-align: center;
    text-shadow: 3px 3px 0 var(--neon-pink), -3px -3px 0 var(--neon-blue);
    animation: glitch 2s infinite alternate;
}
@keyframes glitch {
    0%   { transform: translate(0,0); }
    20%  { transform: translate(-3px,3px); }
    40%  { transform: translate(3px,-3px); }
    60%  { transform: translate(-3px,-3px); }
    80%  { transform: translate(3px,3px); }
}

/* INPUT */
.neon-input {
    background: rgba(0,0,0,.6);
    border: 2px solid #333;
    padding: 10px 20px;
    color: white;
    width: 300px;
    text-align: center;
    font-size: 1.5rem;
    text-transform: uppercase;
}
.neon-input:focus {
    border-color: var(--neon-blue);
    box-shadow: 0 0 15px var(--neon-blue);
}

/* BUTTON */
.cyber-btn {
    background: transparent;
    color: var(--neon-blue);
    border: 2px solid var(--neon-blue);
    padding: 15px 50px;
    font-size: 1.2rem;
    text-transform: uppercase;
    transition: .2s;
    cursor: pointer;
    letter-spacing: 4px;
}
.cyber-btn:hover {
    background: var(--neon-blue);
    color: black;
    box-shadow: 0 0 20px var(--neon-blue);
}

/* COUNTDOWN */
#countdownOverlay {
    position: fixed;
    inset: 0;
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 80;
}

.countdown-text {
    font-size: 8rem;
    font-weight: 900;
    animation: pulseCount .9s ease-out;
}
@keyframes pulseCount {
    0%   { transform: scale(0.5); opacity: 0; }
    50%  { transform: scale(1.2); opacity: 1; }
    100% { transform: scale(1.5); opacity: 0; }
}

/* PAUSE OVERLAY */
#pauseOverlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.7);
    backdrop-filter: blur(6px);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 90;
}
.pause-title {
    font-size: 4rem;
    font-weight: 900;
    text-shadow: 0 0 20px var(--neon-blue);
}

/* GAME OVER MODAL */
#gameOverModal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.9);
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    pointer-events: none;
    z-index: 100;
    transition: .5s;
}
#gameOverModal.active {
    opacity: 1;
    pointer-events: auto;
}

</style>
</head>
<body class="bg-gray-900">

    <!-- SCREEN OVERLAYS -->
    <div class="hyper-overlay"></div>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <!-- START SCREEN -->
    <div id="startScreen">
        <h1 class="title-glitch">NEON<br>RIDER</h1>

        <div class="text-gray-400 mb-8 font-rajdhani tracking-widest text-sm uppercase flex flex-col items-center gap-2">
            <span>System Online</span>
            <span class="text-xs text-gray-600">v.2.3.0 (Leaderboard)</span>
        </div>

        <!-- USERNAME INPUT -->
        <input type="text" id="pilotNameInput" class="neon-input" placeholder="ENTER PILOT NAME"
               maxlength="10" autocomplete="off">

        <!-- START BTN -->
        <button id="startBtn" class="cyber-btn" disabled>INITIALIZE</button>

        <!-- LEADERBOARD (START SCREEN) -->
        <div class="leaderboard-container" style="margin-top:30px;">
            <div class="lb-title">Top 5 Pilots</div>
            <div id="lbListStart">
                <div class="lb-row header">
                    <span class="lb-rank">#</span>
                    <span class="lb-name">PILOT</span>
                    <span class="lb-score">SCORE</span>
                </div>
                <div class="lb-row">
                    <span class="lb-rank">-</span>
                    <span class="lb-name">Loading...</span>
                    <span class="lb-score">---</span>
                </div>
            </div>
        </div>

        <p class="mt-8 text-xs text-gray-600 font-mono">
            [WASD / ARROWS] to Drive &nbsp;|&nbsp; [TOUCH] L/R Sides
        </p>
    </div>

    <!-- COUNTDOWN -->
    <div id="countdownOverlay">
        <div id="countdownText" class="countdown-text">3</div>
    </div>

    <!-- PAUSE BUTTON -->
    <div id="pauseBtn"
         style="position:absolute; top:20px; left:20px; z-index:110; width:40px; height:40px; 
         border:2px solid rgba(255,255,255,0.2); border-radius:50%; display:flex; align-items:center;
         justify-content:center; cursor:pointer; background:rgba(0,0,0,0.5);">
        ||
    </div>

    <!-- PAUSE OVERLAY -->
    <div id="pauseOverlay">
        <h2 class="pause-title">PAUSED</h2>
        <button id="resumeBtn" class="cyber-btn">RESUME</button>
    </div>

    <!-- HUD -->
    <div id="ui-layer">

        <!-- HEADER HUD -->
        <div class="hud-header">

            <!-- SCORE -->
            <div class="hud-box" style="margin-left:60px;">
                <div class="hud-content">
                    <span class="label">Current Score</span>
                    <span id="score" class="value text-yellow-400">0</span>
                </div>
            </div>

            <!-- CENTER DAY/NIGHT STATUS -->
            <div class="hidden md:flex flex-col items-center pt-2 opacity-70">
                <div class="h-1 w-24 bg-gradient-to-r from-transparent via-blue-500 to-transparent mb-1"></div>
                <span id="tipIcon" class="text-xl mb-1">‚òÄÔ∏è</span>
                <span id="tipText" class="text-xs tracking-[0.3em] uppercase">DAY CYCLE</span>
            </div>

            <!-- PILOT + SPEED -->
            <div class="flex gap-4">

                <!-- PILOT NAME -->
                <div class="hud-box right-align">
                    <div class="hud-content">
                        <span class="label">Pilot</span>
                        <span id="pilotNameDisplay" class="value text-purple-400">GUEST</span>
                    </div>
                </div>

                <!-- SPEED + ENERGY -->
                <div class="hud-box right-align" style="min-width:170px;">
                    <div class="hud-content">

                        <div class="flex justify-between items-end">
                            <span class="label">Velocity</span>
                            <span class="hyper-text">HYPER ACTIVE</span>
                        </div>

                        <div class="flex items-baseline justify-center gap-1">
                            <span id="speedDisplay" class="value text-cyan-400">0</span>
                            <span class="text-xs text-cyan-700">KM/H</span>
                        </div>

                        <div class="bars-wrapper">
                            <div class="bar-container">
                                <div id="speedBar" class="speed-bar-fill"></div>
                            </div>
                            <div class="bar-container">
                                <div id="energyBar" class="energy-bar-fill"></div>
                            </div>
                        </div>

                        <div class="text-xs text-gray-500 flex justify-between mt-1">
                            <span>SPD</span>
                            <span>NRG</span>
                        </div>

                    </div>
                </div>

            </div>
        </div>

        <!-- POWERUP BADGES -->
        <div id="statusContainer"
             style="position:absolute; top:100px; right:20px; display:flex; flex-direction:column; gap:12px;">
            
            <div id="shieldBadge" class="status-badge shield-active">
                <span class="text-2xl">üõ°Ô∏è</span>
                <div>
                    <div class="text-xs opacity-70 leading-none">SYSTEM</div>
                    <div>SHIELD</div>
                </div>
            </div>

            <div id="magnetBadge" class="status-badge magnet-active">
                <span class="text-2xl">üß≤</span>
                <div>
                    <div class="text-xs opacity-70 leading-none">FIELD</div>
                    <div>MAGNET</div>
                </div>
            </div>

            <div id="nitroBadge" class="status-badge nitro-active">
                <span class="text-2xl">üöÄ</span>
                <div>
                    <div class="text-xs opacity-70 leading-none">BOOST</div>
                    <div>NITRO</div>
                </div>
            </div>

        </div>

        <!-- KEYBOARD VISUALS (DESKTOP ONLY) -->
        <div class="key-visuals hidden md:flex" style="position:absolute; bottom:30px; right:30px;">
            <div class="key-group">
                <div id="keyW" class="key-box">W</div>
                <div class="key-row" style="display:flex; gap:5px;">
                    <div id="keyA" class="key-box">A</div>
                    <div id="keyS" class="key-box">S</div>
                    <div id="keyD" class="key-box">D</div>
                </div>
            </div>
        </div>

        <!-- MOBILE TOUCH ZONES -->
        <div class="touch-zones md:hidden">
            <div id="leftZone" class="zone"></div>
            <div id="rightZone" class="zone"></div>
        </div>

        <div class="absolute bottom-8 w-full flex justify-between px-8 text-xs text-gray-500 opacity-50 md:hidden pointer-events-none">
            <span>[ HOLD ] BRAKE</span>
            <span>GAS [ HOLD ]</span>
        </div>

    </div>

    <!-- GAME CANVAS -->
    <canvas id="gameCanvas"></canvas>

    <!-- HYPER DRIVE BUTTON -->
    <button id="hyperBtn" class="cyber-btn"
        style="display:none; position:fixed; bottom:130px; left:50%; transform:translateX(-50%);
        z-index:60; padding:10px 35px; font-size:1rem;">
        HYPER-DRIVE
    </button>

    <!-- GAME OVER MODAL -->
    <div id="gameOverModal">
        <div class="bg-gray-900 border border-gray-700 p-8 max-w-sm w-full relative"
             style="clip-path: polygon(20px 0,100% 0,100% calc(100% - 20px),calc(100% - 20px) 100%,0 100%,0 20px);">

            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-red-500 via-pink-500 to-purple-500"></div>

            <h2 class="text-4xl font-black text-center text-white tracking-widest uppercase mb-6">
                CRITICAL<br><span class="text-red-500">FAILURE</span>
            </h2>

            <div class="stats-grid" style="display:grid; grid-template-columns:1fr 1fr; gap:20px;">
                <div class="stat-card">
                    <span class="label text-xs">Score</span>
                    <span id="finalScore" class="value text-2xl text-yellow-400">0</span>
                </div>
                <div class="stat-card">
                    <span class="label text-xs">Best</span>
                    <span id="finalHighScore" class="value text-2xl text-purple-400">0</span>
                </div>
            </div>

            <div id="uploadStatus" class="text-center text-xs mb-4 text-gray-400">Syncing...</div>

            <div class="leaderboard-container" style="width:100%; border:none; background:rgba(255,255,255,0.05);">
                <div class="lb-title" style="font-size:0.8rem;">Live Rankings</div>
                <div id="lbListEnd"></div>
            </div>

            <div id="newRecordMsg" class="hidden text-center text-green-400 font-bold mb-6 tracking-widest animate-pulse">
                ‚òÖ NEW RECORD ESTABLISHED ‚òÖ
            </div>

            <button id="restartButton" class="cyber-btn w-full" style="font-size:1rem; padding:12px;">
                REBOOT SYSTEM
            </button>
        </div>
    </div>
    <script type="module">
        // --- Firebase Integration ---
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        const firebaseConfig = {
          apiKey: "AIzaSyAJgZqipIGDxBoylfgAtr1c8aPVeHMw1rE",
          authDomain: "neondrive-29cf4.firebaseapp.com",
          projectId: "neondrive-29cf4",
          storageBucket: "neondrive-29cf4.firebasestorage.app",
          messagingSenderId: "641671843000",
          appId: "1:641671843000:web:681a3f11e5526da51c784d",
          measurementId: "G-02CFX0F80P"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- Game Globals for Leaderboard ---
        let playerName = "";
        let leaderboardData = [];

        // --- Sound Manager ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        let engineOsc1, engineOsc2, engineNoise, engineFilter, engineMasterGain;
        let isMusicPlaying = false;
        let beatInterval;

        function createNoiseBuffer() {
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            return buffer;
        }

        const noiseBuffer = createNoiseBuffer();

        // Procedural Synthwave Music Generator
        const musicSystem = {
            step: 0,
            tempo: 140,
            start: function() {
                if(isMusicPlaying) return;
                isMusicPlaying = true;
                const beatDuration = 60 / this.tempo * 1000 / 2; // 8th notes
                beatInterval = setInterval(() => this.playStep(), beatDuration);
            },
            stop: function() {
                isMusicPlaying = false;
                clearInterval(beatInterval);
            },
            playStep: function() {
                if(audioCtx.state === 'suspended') return;
                const now = audioCtx.currentTime;
                
                // Kick
                if(this.step % 4 === 0) this.playKick(now);
                // Snare
                if(this.step % 8 === 4) this.playSnare(now);
                // Bass
                this.playBass(now, this.step);

                this.step = (this.step + 1) % 16;
            },
            playKick: function(time) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(0.5, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.start(time); osc.stop(time + 0.5);
            },
            playSnare: function(time) {
                const noise = audioCtx.createBufferSource();
                noise.buffer = noiseBuffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 1000;
                const gain = audioCtx.createGain();
                noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                noise.start(time); noise.stop(time + 0.2);
            },
            playBass: function(time, step) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                osc.type = 'sawtooth';
                filter.type = 'lowpass';
                filter.Q.value = 2;
                osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);

                let freq = 65.41; // C2
                if (step >= 8 && step < 12) freq = 49.00; // G1
                if (step >= 12) freq = 43.65; // F1
                if (step % 2 !== 0) freq *= 2; // Octave on off-beat

                osc.frequency.setValueAtTime(freq, time);
                filter.frequency.setValueAtTime(200, time);
                filter.frequency.exponentialRampToValueAtTime(800, time + 0.1);
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.linearRampToValueAtTime(0, time + 0.2);
                osc.start(time); osc.stop(time + 0.2);
            }
        };

        function startEngine() {
            if (engineOsc1) return;
            engineOsc1 = audioCtx.createOscillator();
            engineOsc2 = audioCtx.createOscillator();
            engineNoise = audioCtx.createBufferSource();
            engineFilter = audioCtx.createBiquadFilter();
            engineMasterGain = audioCtx.createGain();
            
            engineOsc1.type = 'sawtooth'; engineOsc1.frequency.value = 60; 
            engineOsc2.type = 'sine'; engineOsc2.frequency.value = 30;
            engineNoise.buffer = noiseBuffer; engineNoise.loop = true;
            engineFilter.type = 'lowpass'; engineFilter.Q.value = 2;

            engineOsc1.connect(engineFilter); engineOsc2.connect(engineFilter);
            const noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0.05;
            engineNoise.connect(noiseGain); noiseGain.connect(engineMasterGain);
            engineFilter.connect(engineMasterGain); engineMasterGain.connect(audioCtx.destination);

            engineOsc1.start(); engineOsc2.start(); engineNoise.start();
            engineMasterGain.gain.value = 0.1; engineFilter.frequency.value = 200;
        }

        function updateEngine(speed, accelerating) {
            if (!engineOsc1) return;
            const now = audioCtx.currentTime;
            const baseFreq = 60;
            const rpmMultiplier = 1 + (speed * 3);
            const targetFreq = baseFreq * rpmMultiplier;
            engineOsc1.frequency.setTargetAtTime(targetFreq, now, 0.1);
            engineOsc2.frequency.setTargetAtTime(targetFreq * 0.5, now, 0.1);
            engineFilter.frequency.setTargetAtTime(200 + (speed * 2000), now, 0.1);
            engineMasterGain.gain.setTargetAtTime(accelerating ? 0.2 + (speed*0.1) : 0.05 + (speed*0.05), now, 0.1);
        }
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (audioCtx.state === 'running' && !engineOsc1) startEngine();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'coin') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
                gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'energy') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(1600, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'hyper_start') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(1000, now + 2.0);
                gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0.01, now + 2.0);
                osc.start(now); osc.stop(now + 2.0);
            } else if (type === 'boost') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(600, now + 0.3);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'nitro') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(800, now + 1.0);
                gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0.01, now + 1.0);
                osc.start(now); osc.stop(now + 1.0);
            } else if (type === 'break') {
                osc.type = 'square'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            }
        }

        // --- DOM ---
        const canvas = document.getElementById('gameCanvas');
        const scoreEl = document.getElementById('score');
        const speedDisplayEl = document.getElementById('speedDisplay');
        const speedBarEl = document.getElementById('speedBar');
        const energyBarEl = document.getElementById('energyBar');
        
        const modalEl = document.getElementById('gameOverModal');
        const startScreenEl = document.getElementById('startScreen');
        const countdownOverlayEl = document.getElementById('countdownOverlay');
        const countdownTextEl = document.getElementById('countdownText');
        const finalScoreEl = document.getElementById('finalScore');
        const finalHighScoreEl = document.getElementById('finalHighScore');
        const newRecordMsgEl = document.getElementById('newRecordMsg');
        
        const restartButton = document.getElementById('restartButton');
        const startButton = document.getElementById('startBtn');
        const nameInput = document.getElementById('pilotNameInput');
        const pilotNameDisplay = document.getElementById('pilotNameDisplay');
        const uploadStatusEl = document.getElementById('uploadStatus');
        
        const tipTextEl = document.getElementById('tipText');
        const tipIconEl = document.getElementById('tipIcon');
        const shieldBadge = document.getElementById('shieldBadge');
        const magnetBadge = document.getElementById('magnetBadge');
        const nitroBadge = document.getElementById('nitroBadge');

        const keyW = document.getElementById('keyW');
        const keyA = document.getElementById('keyA');
        const keyS = document.getElementById('keyS');
        const keyD = document.getElementById('keyD');

        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const hyperBtn = document.getElementById('hyperBtn');

        // --- Constants ---
        const LANE_COUNT = 3; 
        const LANE_WIDTH = 5; 
        const ROAD_WIDTH = LANE_COUNT * LANE_WIDTH; 
        const ROAD_LENGTH = 100;
        const CAR_BODY_WIDTH = 2.5; 
        const CAR_BODY_HEIGHT = 1.0; 
        const CAR_BODY_DEPTH = 4.5;
        const PLAYER_Z_POSITION = 15; 
        const SPAWN_Z_POSITION = -ROAD_LENGTH * 1.5; 
        const DESPAWN_Z_POSITION = PLAYER_Z_POSITION + 20;
        const HYPER_DURATION = 300; // frames

        // Colors
        const PLAYER_COLOR = 0x3b82f6; 
        const ROAD_COLOR = 0x34495e; 
        const LINE_COLOR = 0xffffff;
        const COIN_COLOR = 0xffd700; 
        const NITRO_COLOR = 0xa855f7; 
        const SPIKE_COLOR = 0xef4444; 
        const ENERGY_COLOR = 0x0aff0a;

        // --- State ---
        let scene, camera, renderer;
        let playerCar, playerShieldMesh, retroSun;
        let roadLines = [];
        let enemies = [], ambulances = [], police = [], trafficLights = [], scenery = [], coins = [], powerups = [], particles = [], spikes = [], energyOrbs = [];
        let score = 0, gameSpeed = 0.3, gameOver = false, animationFrameId;

        let highScore = 0;
        try { highScore = parseInt(localStorage.getItem('neonRideHighScore')) || 0; } catch(e) {}

        let playerLane = 1, playerTargetX = 0;
        let isAccelerating = false, isBraking = false;
        let hasShield = false, hasMagnet = false, magnetTimer = 0, invincibleTimer = 0;
        let isFlying = false, flyTimer = 0;
        let hyperEnergy = 0;
        let isHyperMode = false;
        let hyperTimer = 0;
        
        let CANVAS_WIDTH, CANVAS_HEIGHT, touchStartX = 0;
        let isGameRunning = false;
        let isCountingDown = false;
        let isPaused = false;

        // Day/Night
        let timeOfDay = 0;
        let sunLight, ambientLight;
        let windowTextures = [];

        // --- Leaderboard Functions ---
        function initLeaderboard() {
            const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(5));
            onSnapshot(q, (snapshot) => {
                leaderboardData = [];
                snapshot.forEach((doc) => leaderboardData.push(doc.data()));
                renderLeaderboard('lbListStart');
                renderLeaderboard('lbListEnd');
            });
        }

        function renderLeaderboard(elementId) {
            const container = document.getElementById(elementId);
            if (!container) return;
            
            let html = `
                <div class="lb-row header">
                    <span class="lb-rank">#</span>
                    <span class="lb-name">PILOT</span>
                    <span class="lb-score">SCORE</span>
                </div>
            `;
            
            leaderboardData.forEach((entry, index) => {
                html += `
                <div class="lb-row">
                    <span class="lb-rank">${index + 1}</span>
                    <span class="lb-name">${entry.name}</span>
                    <span class="lb-score">${entry.score}</span>
                </div>`;
            });
            
            if (leaderboardData.length === 0) {
                 html += `<div class="lb-row" style="justify-content:center; opacity:0.5;">No records yet</div>`;
            }

            container.innerHTML = html;
        }

        async function saveScore(finalScore) {
            if (!playerName || finalScore === 0) return;
            uploadStatusEl.textContent = "Syncing Score...";
            uploadStatusEl.style.color = "#9ca3af";
            try {
                await addDoc(collection(db, "leaderboard"), {
                    name: playerName,
                    score: finalScore,
                    date: Date.now()
                });
                uploadStatusEl.textContent = "Score Uploaded!";
                uploadStatusEl.style.color = "#0aff0a";
            } catch (e) {
                console.error("Error adding document: ", e);
                uploadStatusEl.textContent = "Upload Failed (Network)";
                uploadStatusEl.style.color = "#ff003c";
            }
        }

        // --- Utils ---
        function random(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function randomFloat(min, max) { return Math.random() * (max - min) + min; }
        function laneToX(lane) { return (lane - (LANE_COUNT - 1) / 2) * LANE_WIDTH; }

        function createWindowTextures() {
            windowTextures = [];
            const colors = ['#fde047', '#fb923c', '#e0f2fe'];
            for(let i=0; i<3; i++) {
                const cvs = document.createElement('canvas');
                cvs.width = 64; cvs.height = 128;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = '#222';
                ctx.fillRect(0,0,64,128);
                ctx.fillStyle = colors[i];
                for(let y=10; y<120; y+=15) {
                    for(let x=8; x<56; x+=16) {
                        if(Math.random() > 0.3) ctx.fillRect(x, y, 10, 10);
                    }
                }
                const tex = new THREE.CanvasTexture(cvs);
                tex.magFilter = THREE.NearestFilter;
                windowTextures.push(tex);
            }
        }

        // --- Init Scene ---
        function init() {
            createWindowTextures();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 40, 130);

            updateCanvasSize();
            camera = new THREE.PerspectiveCamera(75, CANVAS_WIDTH / CANVAS_HEIGHT, 0.1, 1000);
            camera.position.set(0, 8, PLAYER_Z_POSITION + 7);
            camera.lookAt(0, 0, PLAYER_Z_POSITION - 10);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
            renderer.shadowMap.enabled = true;

            ambientLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.6);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(-20, 50, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.top = 50; sunLight.shadow.camera.bottom = -50;
            sunLight.shadow.camera.left = -50; sunLight.shadow.camera.right = 50;
            scene.add(sunLight);

            // Retro Sun
            const sunGeo = new THREE.CircleGeometry(40, 32);
            const sunCanvas = document.createElement('canvas');
            sunCanvas.width = 128; sunCanvas.height = 128;
            const ctx = sunCanvas.getContext('2d');
            const grd = ctx.createLinearGradient(0, 0, 0, 128);
            grd.addColorStop(0, '#ffff00');
            grd.addColorStop(0.5, '#ff00ff');
            grd.addColorStop(1, '#9900ff');
            ctx.fillStyle = grd;
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            for(let y=64; y<128; y+=8) ctx.fillRect(0, y, 128, 2);
            const sunTex = new THREE.CanvasTexture(sunCanvas);
            const sunMat = new THREE.MeshBasicMaterial({ map: sunTex, transparent: true, opacity: 0.8 });
            retroSun = new THREE.Mesh(sunGeo, sunMat);
            retroSun.position.set(0, 20, -300);
            scene.add(retroSun);

            // Road
            const roadGeometry = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH * 3);
            const roadMaterial = new THREE.MeshStandardMaterial({ color: ROAD_COLOR, roughness: 0.8, metalness: 0.1 });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.z = -ROAD_LENGTH / 2 + PLAYER_Z_POSITION;
            road.receiveShadow = true;
            scene.add(road);

            // Sidewalks
            const sidewalkGeom = new THREE.PlaneGeometry(5, ROAD_LENGTH * 3);
            const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x9ca3af });
            const leftWalk = new THREE.Mesh(sidewalkGeom, sidewalkMat);
            leftWalk.rotation.x = -Math.PI / 2; 
            leftWalk.position.set(-ROAD_WIDTH/2 - 2.5, 0.02, road.position.z);
            leftWalk.receiveShadow = true; scene.add(leftWalk);
            
            const rightWalk = new THREE.Mesh(sidewalkGeom, sidewalkMat);
            rightWalk.rotation.x = -Math.PI / 2; 
            rightWalk.position.set(ROAD_WIDTH/2 + 2.5, 0.02, road.position.z);
            rightWalk.receiveShadow = true; scene.add(rightWalk);

            // Lane Lines
            const lineMat = new THREE.MeshStandardMaterial({ color: LINE_COLOR });
            const lineGeom = new THREE.PlaneGeometry(0.3, 4);
            for (let i = 1; i < LANE_COUNT; i++) {
                const lineX = laneToX(i - 1) + LANE_WIDTH / 2;
                for (let z = -ROAD_LENGTH * 2; z < ROAD_LENGTH * 2; z += 8) {
                    const line = new THREE.Mesh(lineGeom, lineMat);
                    line.rotation.x = -Math.PI / 2; 
                    line.position.set(lineX, 0.03, z);
                    scene.add(line); 
                    roadLines.push(line);
                }
            }

            addEventListeners();
            setHyperBar();
            
            hyperBtn.addEventListener('click', () => {
                if (hyperEnergy >= 100 && !isHyperMode) {
                    triggerHyperMode();
                    hyperBtn.style.display = 'none';
                }
            });
            
            // Start leaderboard
            initLeaderboard();
            
            renderer.render(scene, camera);
        }

        function triggerCountdown() {
            playerName = nameInput.value.trim().toUpperCase() || "UNKNOWN";
            pilotNameDisplay.textContent = playerName;
            
            startScreenEl.classList.add('fade-out');
            modalEl.classList.remove('active');
            uploadStatusEl.textContent = "";

            if(audioCtx.state === 'suspended') audioCtx.resume();
            startEngine();
            musicSystem.start();

            isCountingDown = true;
            isGameRunning = false;
            countdownOverlayEl.style.display = 'flex';
            
            let count = 3;
            countdownTextEl.innerText = count;
            
            const interval = setInterval(() => {
                count--;
                if(count > 0) {
                    countdownTextEl.innerText = count;
                    countdownTextEl.style.animation = 'none';
                    countdownTextEl.offsetHeight;
                    countdownTextEl.style.animation = 'pulseCount 0.9s ease-out';
                } else if (count === 0) {
                    countdownTextEl.innerText = "GO!";
                } else {
                    clearInterval(interval);
                    countdownOverlayEl.style.display = 'none';
                    isCountingDown = false;
                    isGameRunning = true;
                }
            }, 1000);

            resetGame();
        }

        function togglePause() {
            if(gameOver || !isGameRunning || isCountingDown) return;
            isPaused = !isPaused;
            if(isPaused) {
                document.getElementById('pauseOverlay').style.display = 'flex';
                musicSystem.stop();
            } else {
                document.getElementById('pauseOverlay').style.display = 'none';
                musicSystem.start();
            }
        }

        function resetGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (engineMasterGain) engineMasterGain.gain.setTargetAtTime(0.1, audioCtx.currentTime, 0.5);

            score = 0; gameSpeed = 0.3; gameOver = false;
            isAccelerating = false; isBraking = false;
            hasShield = false; hasMagnet = false; magnetTimer = 0; invincibleTimer = 0;
            isFlying = false; flyTimer = 0;
            isPaused = false;
            document.getElementById('pauseOverlay').style.display = 'none';
            
            hyperEnergy = 0;
            isHyperMode = false;
            hyperTimer = 0;
            document.body.classList.remove('hyper-active');
            setHyperBar();
            hyperBtn.style.display = 'none';
            
            shieldBadge.classList.remove('status-active');
            magnetBadge.classList.remove('status-active');
            nitroBadge.classList.remove('status-active');
            
            timeOfDay = 0.8;

            if (playerCar) scene.remove(playerCar);
            if (playerShieldMesh) scene.remove(playerShieldMesh);
            
            [...enemies, ...ambulances, ...police, ...trafficLights, ...scenery, ...coins, ...powerups, ...spikes, ...energyOrbs].forEach(obj => scene.remove(obj.mesh));
            particles.forEach(p => scene.remove(p));
            enemies=[]; ambulances=[]; police=[]; trafficLights=[]; scenery=[]; coins=[]; powerups=[]; particles=[]; spikes=[]; energyOrbs=[];

            for (let z = PLAYER_Z_POSITION; z > SPAWN_Z_POSITION * 1.5; z -= 15) spawnSceneryRow(z);

            playerCar = createCar(PLAYER_COLOR, true);
            playerLane = 1; playerTargetX = laneToX(playerLane);
            playerCar.position.set(playerTargetX, 0, PLAYER_Z_POSITION);
            scene.add(playerCar);
            
            const shieldGeom = new THREE.SphereGeometry(2.5, 16, 16);
            const shieldMat = new THREE.MeshBasicMaterial({ color: 0x3b82f6, transparent: true, opacity: 0.3, wireframe: true });
            playerShieldMesh = new THREE.Mesh(shieldGeom, shieldMat);
            playerShieldMesh.visible = false;
            scene.add(playerShieldMesh);

            scoreEl.textContent = score; 
            speedDisplayEl.textContent = '0';
            speedBarEl.style.width = '0%';
            energyBarEl.style.width = '0%';
            
            animate();
        }

        function triggerHyperMode() {
            if(isHyperMode) return;
            isHyperMode = true;
            hyperTimer = HYPER_DURATION;
            playSound('hyper_start');
            document.body.classList.add('hyper-active');

            // Burst particles
            for(let i=0; i<20; i++) {
                const p = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.5, 5),
                    new THREE.MeshBasicMaterial({color: ENERGY_COLOR})
                );
                p.position.copy(playerCar.position);
                p.position.z -= 5;
                p.userData.vel = new THREE.Vector3(randomFloat(-5,5), randomFloat(-2,5), -2);
                scene.add(p);
                particles.push(p);
            }
        }

        function updateTimeOfDay() {
            timeOfDay += 0.0003; 
            if (timeOfDay > 1) timeOfDay = 0;

            let sunColor = new THREE.Color();
            let skyColor = new THREE.Color();
            let fogColor = new THREE.Color();
            let ambientInt = 0.5;
            let sunInt = 1.0;
            let buildingEmissive = 0;
            let streetLightInt = 0;
            let stateLabel = "";

            if(isHyperMode) {
                stateLabel = "HYPER";
                skyColor.setHex(0x000000);
                fogColor.setHex(0x002200);
                sunColor.setHex(0x0aff0a);
                ambientInt = 0.8;
                buildingEmissive = 1.0;
                streetLightInt = 2.0;
                tipIconEl.textContent = "‚ö°";
            } else {
                if (timeOfDay < 0.25) { 
                    stateLabel = "NIGHT"; 
                    skyColor.setHex(0x050510); 
                    fogColor.setHex(0x050510); 
                    sunColor.setHex(0x444488); 
                    ambientInt = 0.2; sunInt = 0.2; 
                    buildingEmissive = 1.0; 
                    streetLightInt = 1.5;
                    tipIconEl.textContent = "üåô";
                } else if (timeOfDay < 0.75) {
                    stateLabel = "DAY"; 
                    skyColor.setHex(0x87CEEB); 
                    fogColor.setHex(0x87CEEB); 
                    sunColor.setHex(0xffffff);
                    ambientInt = 0.6; sunInt = 1.0; 
                    buildingEmissive = 0; 
                    streetLightInt = 0;
                    tipIconEl.textContent = "‚òÄÔ∏è";
                } else {
                    stateLabel = "DUSK"; 
                    skyColor.lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0x050510), (timeOfDay-0.75)/0.25); 
                    fogColor.copy(skyColor);
                    ambientInt = 0.3; sunInt = 0.5; 
                    buildingEmissive = 0.5; 
                    streetLightInt = 1.0;
                    tipIconEl.textContent = "üåá";
                }
            }

            tipTextEl.textContent = stateLabel;
            scene.background.copy(skyColor);
            scene.fog.color.copy(fogColor);
            sunLight.color.copy(sunColor);
            sunLight.intensity = sunInt;
            ambientLight.intensity = ambientInt;

            scenery.forEach(s => {
                if (s.isBuilding) {
                    if(isHyperMode) s.mesh.material.emissive.setHex(Math.random()>0.5 ? 0x0aff0a : 0x000000);
                    else {
                        s.mesh.material.emissive.setHex(0xffffff);
                        s.mesh.material.emissiveIntensity = buildingEmissive;
                    }
                }
                if (s.isStreetLight) {
                    s.mesh.userData.light.intensity = streetLightInt;
                    if(isHyperMode) s.mesh.userData.light.color.setHex(0xbc13fe);
                    else s.mesh.userData.light.color.setHex(0xffaa00);
                }
            });
        }

        // --- Player Update ---
        function updatePlayer() {
            let targetTilt = (playerTargetX - playerCar.position.x) * -0.05;
            playerCar.rotation.z += (targetTilt - playerCar.rotation.z) * 0.1;
            playerCar.position.x += (playerTargetX - playerCar.position.x) * 0.15;

            let targetY = 0;
            let targetRotX = 0;
            
            if (flyTimer > 0) {
                flyTimer--;
                targetY = 5.0;
                targetRotX = -0.15;
                if (flyTimer < 30) targetRotX = 0.1;
                
                if(Math.random() > 0.5) {
                    const p = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 0.2, 0.5),
                        new THREE.MeshBasicMaterial({color: 0x3b82f6, transparent: true, opacity: 1.0})
                    );
                    p.position.copy(playerCar.position);
                    p.position.y += 1.0;
                    p.position.z += 2.5;
                    p.userData.vel = new THREE.Vector3(randomFloat(-0.2, 0.2), randomFloat(-0.2, 0.2), 1.0);
                    scene.add(p);
                    particles.push(p);
                }

                if (flyTimer === 0) {
                    isFlying = false;
                    nitroBadge.classList.remove('status-active');
                }
            }
            
            if (isHyperMode) {
                playerCar.position.x += randomFloat(-0.1, 0.1);
                targetRotX = 0;
                const p = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.1, 2),
                    new THREE.MeshBasicMaterial({color: ENERGY_COLOR, transparent: true, opacity: 0.5})
                );
                p.position.copy(playerCar.position);
                p.userData.vel = new THREE.Vector3(0,0,2);
                scene.add(p);
                particles.push(p);
            }
            
            playerCar.position.y += (targetY - playerCar.position.y) * 0.1;
            playerCar.rotation.x = targetRotX;

            playerCar.userData.box.setFromObject(playerCar.children[0]);
            
            retroSun.position.x = camera.position.x * 0.5;
            retroSun.position.z = camera.position.z - 400;
        }

        function updateRoadLines(speed) {
            roadLines.forEach(line => {
                line.position.z += speed;
                if (line.position.z > DESPAWN_Z_POSITION) line.position.z -= ROAD_LENGTH * 4;
            });
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                if (!p.userData.vel) continue;
                p.position.add(p.userData.vel);
                if(isHyperMode) p.userData.vel.z += 0.5; 
                if (p.material && 'opacity' in p.material) {
                    p.material.opacity -= 0.05;
                }
                if(!p.material || p.material.opacity <= 0 || p.position.y < 0) {
                    scene.remove(p);
                    particles.splice(i,1);
                }
            }
        }

        // --- Object Creators ---
        function createBuilding() {
            const h = randomFloat(10,25);
            const w = randomFloat(6,12);
            const d = randomFloat(6,12);
            const tex = windowTextures[random(0,windowTextures.length-1)];
            const mat = new THREE.MeshStandardMaterial({
                color:0x222222,
                map:tex,
                emissive:0xffffff,
                emissiveMap:tex,
                emissiveIntensity:0
            });
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d),mat);
            mesh.position.y=h/2;
            mesh.castShadow=true;
            mesh.receiveShadow=true;
            return mesh;
        }

        function createStreetLight() {
            const g=new THREE.Group();
            const p=new THREE.Mesh(
                new THREE.CylinderGeometry(0.15,0.15,10,6),
                new THREE.MeshStandardMaterial({color:0x1f2937})
            );
            p.position.y=5; g.add(p);
            const a=new THREE.Mesh(
                new THREE.BoxGeometry(3,0.15,0.15),
                new THREE.MeshStandardMaterial({color:0x1f2937})
            );
            a.position.set(1,9.8,0); g.add(a);
            const b=new THREE.Mesh(
                new THREE.BoxGeometry(0.8,0.2,0.4),
                new THREE.MeshStandardMaterial({color:0xffffaa,emissive:0xffffaa})
            );
            b.position.set(2.2,9.6,0); g.add(b);
            const l=new THREE.PointLight(0xffaa00,0,30);
            l.position.set(2.2,9,0); g.add(l);
            g.userData.light=l;
            return g;
        }

        function createCar(color, isPlayer=false) { 
            const car = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.6, roughness: 0.2 });
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(CAR_BODY_WIDTH, 0.8, CAR_BODY_DEPTH), bodyMat);
            chassis.position.y = 0.9; chassis.castShadow = true; car.add(chassis);
            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(CAR_BODY_WIDTH*0.75, 0.6, CAR_BODY_DEPTH*0.4),
                new THREE.MeshStandardMaterial({ color: 0x111, roughness: 0})
            );
            cabin.position.set(0, 1.6, -0.2); car.add(cabin);
            
            if(isPlayer) {
                const hl = new THREE.SpotLight(0xffffff, 2, 60, 0.5, 0.5); 
                hl.position.set(0,1,-2.2); hl.target.position.set(0,0,-20);
                car.add(hl); car.add(hl.target);
            }

            const wG = new THREE.CylinderGeometry(0.5,0.5,0.3,16); 
            wG.rotateZ(Math.PI/2); 
            const wM=new THREE.MeshStandardMaterial({color:0x111});
            [[-1,0.7],[1,0.7],[-1,-0.7],[1,-0.7]].forEach(p=>{
                const w=new THREE.Mesh(wG,wM); w.position.set(p[0]*1.25,0.5,p[1]*2.25); car.add(w);
            });
            car.userData.box = new THREE.Box3().setFromObject(chassis);
            return car;
        }

        function createTruck(color) {
            const group = new THREE.Group();
            const matBody = new THREE.MeshStandardMaterial({ color, roughness: 0.2, metalness: 0.5 });
            const matDark = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
            const matChrome = new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 0.9, roughness: 0.1 });
            const matGlass = new THREE.MeshStandardMaterial({ color: 0x112233, metalness: 0.9, roughness: 0.0 });

            const chassisGeo = new THREE.BoxGeometry(2.4, 0.5, 7.5);
            const chassis = new THREE.Mesh(chassisGeo, matDark);
            chassis.position.y = 0.8;
            chassis.castShadow = true;
            group.add(chassis);

            const cabinGroup = new THREE.Group();
            cabinGroup.position.set(0, 0.8, -2.5);
            const cabGeo = new THREE.BoxGeometry(2.5, 2.0, 2.2);
            const cab = new THREE.Mesh(cabGeo, matBody);
            cab.position.y = 1.0;
            cabinGroup.add(cab);

            const windGeo = new THREE.BoxGeometry(2.3, 0.8, 0.1);
            const wind = new THREE.Mesh(windGeo, matGlass);
            wind.position.set(0, 1.4, -1.11);
            wind.rotation.x = -0.1;
            cabinGroup.add(wind);

            const grilleGeo = new THREE.BoxGeometry(2.0, 0.8, 0.1);
            const grille = new THREE.Mesh(grilleGeo, matChrome);
            grille.position.set(0, 0.6, -1.11);
            cabinGroup.add(grille);

            const stackGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.5, 8);
            const stack1 = new THREE.Mesh(stackGeo, matChrome);
            stack1.position.set(-1.4, 1.5, 0.8);
            cabinGroup.add(stack1);
            const stack2 = stack1.clone();
            stack2.position.set(1.4, 1.5, 0.8);
            cabinGroup.add(stack2);

            chassis.add(cabinGroup);

            const containerGeo = new THREE.BoxGeometry(2.6, 2.8, 4.8);
            const container = new THREE.Mesh(containerGeo, matBody);
            container.position.set(0, 1.7, 1.4);
            chassis.add(container);

            const ribGeo = new THREE.BoxGeometry(2.65, 2.7, 0.2);
            for(let i=0; i<3; i++) {
                const rib = new THREE.Mesh(ribGeo, matDark);
                rib.position.z = -1.5 + (i * 1.5);
                container.add(rib);
            }

            const wheelGeo = new THREE.CylinderGeometry(0.65, 0.65, 0.5, 16);
            wheelGeo.rotateZ(Math.PI/2);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const rimMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const wheelPositions = [
                [-1.3, 0, -2.5], [1.3, 0, -2.5],
                [-1.3, 0, 0.8],  [1.3, 0, 0.8],
                [-1.3, 0, 2.8],  [1.3, 0, 2.8]
            ];
            wheelPositions.forEach(pos => {
                const w = new THREE.Mesh(wheelGeo, wheelMat);
                w.position.set(...pos);
                const rim = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.52, 8), rimMat);
                rim.rotateZ(Math.PI/2);
                w.add(rim);
                chassis.add(w);
            });

            group.userData.box = new THREE.Box3().setFromObject(chassis);
            return group;
        }

        function createBike(color) {
            const group = new THREE.Group();
            const matFrame = new THREE.MeshStandardMaterial({ color, metalness: 0.8, roughness: 0.2, emissive: color, emissiveIntensity: 0.2 });
            const matDark = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
            const matGlow = new THREE.MeshBasicMaterial({ color });
            const matRider = new THREE.MeshStandardMaterial({ color: 0x222222 });

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 1.8), matFrame);
            body.position.y = 0.7;
            body.castShadow = true;
            group.add(body);

            const wheelGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.3, 24);
            wheelGeo.rotateZ(Math.PI/2);
            const frontWheel = new THREE.Mesh(wheelGeo, matDark);
            frontWheel.position.set(0, -0.2, -0.9);
            body.add(frontWheel);
            const rearWheel = new THREE.Mesh(wheelGeo, matDark);
            rearWheel.position.set(0, -0.2, 0.9);
            body.add(rearWheel);

            const rimGeo = new THREE.TorusGeometry(0.4, 0.05, 8, 24);
            rimGeo.rotateY(Math.PI/2);
            frontWheel.add(new THREE.Mesh(rimGeo, matGlow));
            rearWheel.add(new THREE.Mesh(rimGeo, matGlow));

            const fairing = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.8), matFrame);
            fairing.position.set(0, 0.3, -0.6);
            body.add(fairing);

            const wind = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.5), new THREE.MeshStandardMaterial({color:0x000000}));
            wind.position.set(0, 0.4, -0.2);
            wind.rotation.x = -0.5;
            fairing.add(wind);

            const riderGroup = new THREE.Group();
            riderGroup.position.set(0, 0.4, 0.2);
            body.add(riderGroup);

            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.3), matRider);
            torso.rotation.x = 0.5; 
            riderGroup.add(torso);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.28), matRider);
            head.position.set(0, 0.5, -0.3);
            riderGroup.add(head);

            group.userData.box = new THREE.Box3().setFromObject(body);
            return group;
        }

        function createTree() { 
            const g = new THREE.Group(); 
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.4,2), new THREE.MeshStandardMaterial({color:0x5d4037}));
            trunk.position.y=1;
            g.add(trunk);
            const crown = new THREE.Mesh(new THREE.DodecahedronGeometry(1.5), new THREE.MeshStandardMaterial({color:0x2e7d32}));
            crown.position.y=2;
            g.add(crown);
            return g; 
        }

        function createBolt() {
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffaa00, emissiveIntensity: 0.8 });
            const top = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.2), mat);
            top.rotation.z = 0.6;
            top.position.set(0.15, 0.25, 0);
            g.add(top);
            const bot = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.2), mat);
            bot.rotation.z = 0.6;
            bot.position.set(-0.15, -0.25, 0);
            g.add(bot);
            const halo = new THREE.Mesh(new THREE.SphereGeometry(0.7, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.2, wireframe:true }));
            g.add(halo);
            return g;
        }

        function createMagnet() {
            const g = new THREE.Group();
            const matRed = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.5, roughness: 0.2 });
            const matSilver = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });

            const base = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.2), matRed);
            base.position.y = -0.3; g.add(base);
            const left = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.2), matRed);
            left.position.set(-0.2, 0.05, 0); g.add(left);
            const right = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.2), matRed);
            right.position.set(0.2, 0.05, 0); g.add(right);
            const tipL = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.15, 0.22), matSilver);
            tipL.position.set(-0.2, 0.375, 0); g.add(tipL);
            const tipR = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.15, 0.22), matSilver);
            tipR.position.set(0.2, 0.375, 0); g.add(tipR);
            return g;
        }

        function createShieldIcon() {
            const g = new THREE.Group();
            const matBlue = new THREE.MeshStandardMaterial({ color: 0x0088ff, emissive: 0x0044aa, metalness: 0.8 });
            const plate = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 0.1, 6), matBlue);
            plate.rotation.x = Math.PI/2;
            g.add(plate);
            return g;
        }

        function createPowerup(type) { 
            const g=new THREE.Group(); 
            let mesh;
            if (type === 'SHIELD') mesh = createShieldIcon();
            else if (type === 'MAGNET') mesh = createMagnet();
            else mesh = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.7,0.7), new THREE.MeshStandardMaterial({color:NITRO_COLOR,emissiveIntensity:0.5,emissive:NITRO_COLOR}));
            g.add(mesh);
            g.userData.box=new THREE.Box3().setFromObject(mesh);
            g.userData.type=type; 
            return g; 
        }

        function createSpike() {
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({color: SPIKE_COLOR, metalness: 0.8, roughness: 0.2});
            for(let i=-1.5; i<=1.5; i+=1.0) {
                const s = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.2, 8), mat);
                s.position.x = i;
                s.position.y = 0.6;
                g.add(s);
            }
            const base = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 1), new THREE.MeshStandardMaterial({color: 0x333333}));
            base.position.y = 0.05;
            g.add(base);
            g.userData.box = new THREE.Box3().setFromObject(g);
            return g;
        }

        function createCoin() { 
            const c=new THREE.Mesh(new THREE.CylinderGeometry(0.7,0.7,0.1,16), new THREE.MeshStandardMaterial({color:COIN_COLOR, emissive:0xaa8800})); 
            c.rotation.x=Math.PI/2; 
            const g=new THREE.Group(); 
            g.add(c); 
            g.userData.box=new THREE.Box3().setFromObject(c); 
            return g; 
        }

        function createEnergyBar() {
            const group = createBolt();
            group.scale.set(1.2, 1.2, 1.2);
            group.userData.box = new THREE.Box3().setFromObject(group);
            return group;
        }

        // --- Game Objects Update ---
        function updateGameObjects(speed) {
            scenery.forEach((s,i)=>{
                s.mesh.position.z+=speed; 
                if(s.mesh.position.z>DESPAWN_Z_POSITION){
                    scene.remove(s.mesh);
                    scenery.splice(i,1);
                }
            });
            
            const updateObj = (list, type) => {
                for(let i=list.length-1; i>=0; i--) {
                    let o = list[i]; 
                    o.mesh.position.z+=speed; 
                    
                    if(type==='POWERUP') { 
                        o.mesh.rotation.y += 0.05; 
                        o.mesh.position.y = 1.2 + Math.sin(Date.now() * 0.005 + i) * 0.1;
                    }
                    if(type==='COIN') o.mesh.rotation.y += 0.05; 
                    if(type==='ENERGY') {
                        o.mesh.rotation.y += 0.05;
                        const s = 1.2 + Math.sin(Date.now() * 0.01) * 0.2;
                        o.mesh.scale.set(s, s, s);
                        o.mesh.position.y = 1.2 + Math.sin(Date.now() * 0.003) * 0.2;
                    }

                    o.mesh.updateMatrixWorld(); 
                    if (!o.mesh.userData.box) o.mesh.userData.box = new THREE.Box3();
                    o.mesh.userData.box.setFromObject(o.mesh);
                    
                    if(type==='COIN' && hasMagnet && o.mesh.position.z > -40 && o.mesh.position.z < 20) {
                        o.mesh.position.x += (playerCar.position.x - o.mesh.position.x)*0.2;
                        o.mesh.position.z += (playerCar.position.z - o.mesh.position.z)*0.2;
                        o.mesh.position.y += (playerCar.position.y - o.mesh.position.y)*0.2;
                    }

                    if(checkCollision(playerCar, o.mesh)) {
                        if(type==='ENEMY'||type==='POLICE'||type==='SPIKE') {
                            // Hyper Mode: Smash vehicles (Option 1A)
                            if (isHyperMode) {
                                score += 150;
                                for (let p = 0; p < 12; p++) {
                                    const part = new THREE.Mesh(
                                        new THREE.BoxGeometry(0.4, 0.4, 0.4),
                                        new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.9 })
                                    );
                                    part.position.copy(o.mesh.position);
                                    part.userData.vel = new THREE.Vector3(
                                        randomFloat(-0.8, 0.8),
                                        randomFloat(0.3, 1.2),
                                        randomFloat(-0.8, 0.8)
                                    );
                                    scene.add(part);
                                    particles.push(part);
                                }
                                scene.remove(o.mesh);
                                list.splice(i, 1);
                                continue;
                            }

                            if(!hasShield && invincibleTimer===0) {
                                endGame();
                            } else { 
                                if(hasShield) {
                                    hasShield=false;
                                    shieldBadge.classList.remove('status-active');
                                    playSound('break');
                                    invincibleTimer=60;
                                } 
                                scene.remove(o.mesh); 
                                list.splice(i,1); 
                                continue;
                            } 
                        }
                        else if(type==='COIN') { 
                            score+=25; 
                            playSound('coin'); 
                            scene.remove(o.mesh); 
                            list.splice(i,1); 
                        }
                        else if(type==='POWERUP') { 
                            if(o.type==='SHIELD'){ 
                                playSound('boost'); 
                                hasShield=true;
                                shieldBadge.classList.add('status-active'); 
                            }
                            else if(o.type==='NITRO'){ 
                                playSound('nitro'); 
                                isFlying=true; 
                                flyTimer=400; 
                                nitroBadge.classList.add('status-active'); 
                            }
                            else{ 
                                playSound('boost'); 
                                hasMagnet=true;
                                magnetTimer=600;
                                magnetBadge.classList.add('status-active'); 
                            } 
                            scene.remove(o.mesh); 
                            list.splice(i,1); 
                        }
                        else if (type === 'ENERGY') {
                            if (hyperEnergy < 100) {
                                hyperEnergy = Math.min(100, hyperEnergy + (100/7)); // 7 pickups -> full
                                setHyperBar();
                                playSound('boost');
                                if (hyperEnergy >= 99 && !isHyperMode) {
                                    hyperBtn.style.display = 'block';
                                }
                            }
                            scene.remove(o.mesh);
                            list.splice(i, 1);
                            continue;
                        }
                    } else if(o.mesh.position.z>DESPAWN_Z_POSITION) { 
                        if(type==='ENEMY') score+=10; 
                        scene.remove(o.mesh); 
                        list.splice(i,1); 
                    }
                }
            };
            updateObj(enemies, 'ENEMY'); 
            updateObj(police, 'POLICE'); 
            updateObj(powerups, 'POWERUP'); 
            updateObj(coins, 'COIN'); 
            updateObj(spikes, 'SPIKE');
            updateObj(energyOrbs, 'ENERGY');
            
            if(hasMagnet) { magnetTimer--; if(magnetTimer<=0) {hasMagnet=false; magnetBadge.classList.remove('status-active');} }
            if(invincibleTimer>0) invincibleTimer--;
            
            playerShieldMesh.visible = hasShield;
            playerShieldMesh.position.copy(playerCar.position); 
            playerShieldMesh.position.y+=1; 
            playerShieldMesh.rotation.y+=0.1;
        }

        function spawnSceneryRow(zPos) {
            [1, -1].forEach(side => {
                if(Math.random()>0.3) {
                    const r = Math.random();
                    let m, isB=false, isL=false;
                    let x = (side*ROAD_WIDTH/2) + (side*5) + (side*randomFloat(0,5));
                    if(r<0.2) { 
                        m=createStreetLight(); 
                        x=side*(ROAD_WIDTH/2+2.5); 
                        m.rotation.y=side*-Math.PI/2; 
                        isL=true; 
                    }
                    else if(r<0.5) m=createTree();
                    else { m=createBuilding(); x+=side*10; isB=true; }
                    m.position.set(x,0,zPos); 
                    scene.add(m);
                    scenery.push({mesh:m, isBuilding:isB, isStreetLight:isL});
                }
            });
        }

        function spawnObjects() {
            if(Math.random()<0.05) spawnSceneryRow(SPAWN_Z_POSITION);
            
            if(Math.random()<0.008 && isLaneClear(1)) {
                const lane=random(0,2);
                if(isLaneClear(lane)) {
                    const m=createSpike(); 
                    m.position.set(laneToX(lane),0,SPAWN_Z_POSITION);
                    spikes.push({mesh:m, lane}); 
                    scene.add(m);
                }
            }

            // Enemies: cars, trucks, bikes
            if(Math.random()<0.015 && isLaneClear(1)) {
                const lane=random(0,2); 
                if(isLaneClear(lane)) {
                    const rType = Math.random();
                    let m;
                    if (rType < 0.6) {
                        m = createCar(0xff0000); 
                    } else if (rType < 0.85) {
                        const tCol = Math.random() > 0.5 ? 0xff5500 : 0xcccccc;
                        m = createTruck(tCol);
                    } else {
                        const bCol = Math.random() > 0.5 ? 0x00ff00 : 0xff00ff;
                        m = createBike(bCol);
                    }
                    m.position.set(laneToX(lane),0,SPAWN_Z_POSITION); 
                    enemies.push({mesh:m, lane}); 
                    scene.add(m);
                }
            }

            if(Math.random()<0.004) {
                const lane=random(0,2); 
                const r=Math.random();
                let t='SHIELD';
                if(r<0.33) t='MAGNET';
                else if(r<0.66) t='NITRO';
                const m=createPowerup(t);
                m.position.set(laneToX(lane),1.2,SPAWN_Z_POSITION); 
                powerups.push({mesh:m,lane,type:t}); 
                scene.add(m);
            }

            if(Math.random() < 0.1 && isLaneClear(1)) {
                const lane = random(0, 2);
                const isSky = isFlying ? (Math.random() < 0.9) : (Math.random() < 0.05);
                const y = isSky ? 5.0 : 1.0;
                const m = createCoin();
                m.position.set(laneToX(lane), y, SPAWN_Z_POSITION);
                coins.push({mesh:m, lane});
                scene.add(m);
            }

            if (Math.random() < 0.004 && isLaneClear(1)) {
                const lane = random(0, 2);
                const e = createEnergyBar();
                e.position.set(laneToX(lane), 1.2, SPAWN_Z_POSITION);
                energyOrbs.push({ mesh:e, lane });
                scene.add(e);
            }
        }

        // FIXED: Proper lane check so obstacles don't overlap
        function isLaneClear(lane) {
            const minZ = SPAWN_Z_POSITION - 5;
            const maxZ = SPAWN_Z_POSITION + 20;
            const checkList = (list) => {
                for (let obj of list) {
                    if (obj.lane === lane && obj.mesh.position.z > minZ && obj.mesh.position.z < maxZ) {
                        return false;
                    }
                }
                return true;
            };
            return checkList(enemies) && checkList(spikes);
        }

        function checkCollision(a,b) { 
            return a.userData.box && b.userData.box && a.userData.box.intersectsBox(b.userData.box); 
        }

        // --- Main Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if(!gameOver) {
                if(isCountingDown || isPaused) {
                    renderer.render(scene, camera);
                    return;
                }

                let speedMult = isAccelerating ? 2.0 : (isBraking ? 0.5 : 1.0);
                if (isHyperMode) speedMult *= 2.2;
                let currentSpeed = gameSpeed * speedMult;
                
                updateTimeOfDay();
                updateEngine(currentSpeed, isAccelerating);
                updatePlayer();
                updateRoadLines(currentSpeed);
                updateGameObjects(currentSpeed);
                updateParticles(); 
                spawnObjects();
                
                if (isHyperMode) {
                    hyperTimer--;
                    hyperEnergy = (hyperTimer / HYPER_DURATION) * 100;
                    setHyperBar();
                    if (hyperTimer <= 0) {
                        deactivateHyperDrive();
                    }
                    for (let s = 0; s < 3; s++) {
                        const sl = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 0.1, randomFloat(3, 7)),
                            new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.7 })
                        );
                        const side = Math.random() < 0.5 ? -1 : 1;
                        sl.position.set(
                            camera.position.x + side * randomFloat(4, 8),
                            randomFloat(1, 4),
                            camera.position.z - randomFloat(8, 16)
                        );
                        sl.userData.vel = new THREE.Vector3(0,0,currentSpeed * 8);
                        scene.add(sl);
                        particles.push(sl);
                    }
                }

                scoreEl.textContent = Math.floor(score);
                const displaySpeed = (currentSpeed * 200).toFixed(0);
                speedDisplayEl.textContent = displaySpeed;
                const percentage = Math.min((currentSpeed / 2.0) * 100, 100);
                speedBarEl.style.width = percentage + '%';

                gameSpeed = Math.min(gameSpeed+0.0001, 1.0);
                
                let targetFov = 75;
                if (isHyperMode) targetFov = 110;
                else if (isAccelerating) targetFov = 85;
                camera.fov += (targetFov - camera.fov) * 0.08;
                camera.updateProjectionMatrix();

                renderer.render(scene, camera);
            } else {
                updateParticles(); 
                renderer.render(scene, camera);
            }
        }

        // --- Input & Helpers ---
        function movePlayer(d) { 
            playerLane=Math.max(0,Math.min(2,playerLane+d)); 
            playerTargetX=laneToX(playerLane); 
        }

        function updateCanvasSize() { 
            CANVAS_WIDTH=window.innerWidth; CANVAS_HEIGHT=window.innerHeight;
            canvas.width=CANVAS_WIDTH; canvas.height=CANVAS_HEIGHT;
            if(camera){camera.aspect=CANVAS_WIDTH/CANVAS_HEIGHT; camera.updateProjectionMatrix();}
            if(renderer)renderer.setSize(CANVAS_WIDTH,CANVAS_HEIGHT);
        }

        function addEventListeners() {
            window.addEventListener('resize', updateCanvasSize);
            
            nameInput.addEventListener('input', (e) => {
                const val = e.target.value.trim();
                startButton.disabled = val.length === 0;
            });

            window.addEventListener('keydown', e=>{
                if(e.key === 'Escape' || e.key === 'p') { togglePause(); return; }
                if(!isGameRunning && (e.key === 'Enter') && !startButton.disabled) { triggerCountdown(); return; }
                if(gameOver || isPaused || !isGameRunning) return; 
                
                if(e.key === 'w' || e.key === 'ArrowUp') keyW?.classList.add('active');
                if(e.key === 'a' || e.key === 'ArrowLeft') keyA?.classList.add('active');
                if(e.key === 's' || e.key === 'ArrowDown') keyS?.classList.add('active');
                if(e.key === 'd' || e.key === 'ArrowRight') keyD?.classList.add('active');

                if(e.key==='a'||e.key==='ArrowLeft')movePlayer(-1); 
                if(e.key==='d'||e.key==='ArrowRight')movePlayer(1);
                if(e.key==='w'||e.key==='ArrowUp')isAccelerating=true; 
                if(e.key==='s'||e.key==='ArrowDown')isBraking=true;
            });

            window.addEventListener('keyup', e=>{
                if(e.key === 'w' || e.key === 'ArrowUp') keyW?.classList.remove('active');
                if(e.key === 'a' || e.key === 'ArrowLeft') keyA?.classList.remove('active');
                if(e.key === 's' || e.key === 'ArrowDown') keyS?.classList.remove('active');
                if(e.key === 'd' || e.key === 'ArrowRight') keyD?.classList.remove('active');

                if(e.key==='w'||e.key==='ArrowUp')isAccelerating=false; 
                if(e.key==='s'||e.key==='ArrowDown')isBraking=false;
            });
            
            restartButton.addEventListener('click', ()=>{ 
                modalEl.classList.remove('active');
                triggerCountdown(); 
            });
            
            startButton.addEventListener('click', ()=>{ triggerCountdown(); });
            pauseBtn.addEventListener('click', togglePause);
            resumeBtn.addEventListener('click', togglePause);

            const leftZone = document.getElementById('leftZone');
            const rightZone = document.getElementById('rightZone');

            window.addEventListener('touchstart', e=>{
                if(gameOver || isPaused) return;
                touchStartX=e.touches[0].clientX; 
            }, {passive:false});
            
            window.addEventListener('touchend', e=>{
                if(gameOver || isPaused) return; 
                const d=e.changedTouches[0].clientX-touchStartX; 
                if(Math.abs(d)>30) movePlayer(d>0?1:-1); 
            });

            leftZone.addEventListener('touchstart', (e) => { e.preventDefault(); isBraking = true; });
            leftZone.addEventListener('touchend', (e) => { e.preventDefault(); isBraking = false; });
            
            rightZone.addEventListener('touchstart', (e) => { e.preventDefault(); isAccelerating = true; });
            rightZone.addEventListener('touchend', (e) => { e.preventDefault(); isAccelerating = false; });
        }
        
        function setHyperBar() {
            if (!energyBarEl) return;
            energyBarEl.style.width = Math.min(100, Math.max(0, hyperEnergy)) + '%';
        }

        function deactivateHyperDrive() {
            isHyperMode = false;
            document.body.classList.remove('hyper-active');
            hyperEnergy = 0;
            setHyperBar();
        }

        function endGame() {
            if (gameOver) return;
            gameOver = true;
            isGameRunning = false;
            isPaused = false;
            document.getElementById('pauseOverlay').style.display = 'none';
            musicSystem.stop();

            const final = Math.floor(score);
            finalScoreEl.textContent = final;

            if (final > highScore) {
                highScore = final;
                try { localStorage.setItem('neonRideHighScore', highScore); } catch(e){}
                newRecordMsgEl.classList.remove('hidden');
            } else {
                newRecordMsgEl.classList.add('hidden');
            }
            finalHighScoreEl.textContent = highScore;

            modalEl.classList.add('active');
            saveScore(final);
        }

        // Start the game
        init();
    </script>
</body>
</html>
